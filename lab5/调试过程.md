# lab5 调试过程记录

## 调试会话 1

### 问题：这个调试结果是什么意思？

**GDB 输出：**
```
0x0000000000001000 in ?? ()
(gdb) b kern_entry
Breakpoint 1 at 0xffffffffc0200000: file kern/init/entry.S, line 10.
(gdb) b user/libs/syscall.c:26
No source file named user/libs/syscall.c.
<ture shared library load? (y or [n]) y
Breakpoint 2 (user/libs/syscall.c:26) pending.
(gdb) b syscall
Breakpoint 3 at 0xffffffffc020543a: file kern/syscall/syscall.c, line 83.
(gdb)
```

**解释：**

- `0x0000000000001000 in ?? ()`：程序当前停在地址 0x0000000000001000 处，`?? ()` 表示 GDB 无法确定该地址对应的函数名。这通常发生在程序启动的早期阶段，比如在内核初始化之前，或者当调试信息不完整时。在这个操作系统实验中，这可能是内核加载后的初始执行点。

- `b kern_entry`：设置断点在 `kern_entry` 函数上。成功设置，断点编号 1，位于地址 0xffffffffc0200000，对应文件 `kern/init/entry.S` 第 10 行。这是内核入口点的汇编代码。

- `b user/libs/syscall.c:26`：尝试在 `user/libs/syscall.c` 文件的第 26 行设置断点，但 GDB 报告找不到该源文件。这可能是因为该文件位于用户空间，而当前调试的是内核空间，或者调试信息未加载。GDB 提示是否加载共享库，用户输入 `y`（虽然输出中写成了 `<ture shared library load? (y or [n]) y`，可能是打字错误，应该是 "true"），然后断点设置为 "pending"，意味着它将在库加载时生效。

- `b syscall`：设置断点在 `syscall` 函数上。成功设置，断点编号 3，位于地址 0xffffffffc020543a，对应文件 `kern/syscall/syscall.c` 第 83 行。这是内核中的系统调用处理函数。

这个调试会话显示了在 lab5（涉及进程管理和系统调用的实验）中设置断点的过程，准备调试内核和用户空间的交互。

## 调试会话 2

### 问题：这个调试结果是什么意思？

**GDB 终端输出：**
```
Breakpoint 3, syscall () at kern/syscall/syscall.c:83      
83          struct trapframe *tf = current->tf;
(gdb) c
Continuing.

Breakpoint 3, syscall () at kern/syscall/syscall.c:83      
83          struct trapframe *tf = current->tf;
```

**make debug 终端输出：**
```
Store/AMO page fault
Store/AMO page fault
```

**解释：**

- **GDB 终端：** 断点 3 在 `syscall` 函数的第 83 行触发，代码是 `struct trapframe *tf = current->tf;`。`current` 指向当前进程的 PCB（Process Control Block），`tf` 是陷阱帧（trapframe），用于保存系统调用时的上下文。执行 `c`（continue）后，程序继续运行，但很快再次触发同一个断点，表明系统调用被频繁调用或循环触发。这在 lab5 中常见，因为进程管理和系统调用（如 fork、exit 等）会涉及多次系统调用。

- **make debug 终端：** 出现了两次 "Store/AMO page fault"。这是一个页面错误（page fault），"Store/AMO" 表示错误类型为存储操作或原子内存操作（Atomic Memory Operation），通常发生在尝试写入只读页面或未映射的内存时。在 lab5 的 COW（Copy-on-Write）机制中，这可能是因为写时复制触发：当进程尝试写入共享的只读页面时，内核会捕获页面错误，复制页面，并更新映射。这会导致页面错误输出，表示内存管理正在处理写时复制。

结合项目上下文，lab5 涉及进程创建、内存共享和 COW，这解释了系统调用断点触发和页面错误的出现。如果页面错误频繁，可能需要检查 COW 实现是否正确。

## 调试会话 3

### 问题：目前的内核是如何将用户程序加载进去的，如果我想要调试内核上运行的用户程序，是不是需要将用户程序的符号表也都加载进去，我应该怎么操作，为什么使用 make debug 和 make gdb 调试的时候就会自动将内核符号表加载进去。

**内核加载用户程序的过程：**

内核通过 `exec` 系统调用加载用户程序。具体流程如下（基于 `kern/process/proc.c` 中的 `do_execve` 和 `load_icode` 函数）：

1. **系统调用入口：** 用户程序调用 `exec` 系统调用，传递程序名、二进制数据等参数。内核在 `kern/syscall/syscall.c` 的 `sys_exec` 中处理，调用 `do_execve`。

2. **清理旧内存空间：** `do_execve` 首先检查参数有效性，然后清理当前进程的旧内存映射（`mm_struct`），释放页目录和内存空间。

3. **加载新程序：** 调用 `load_icode(binary, size)` 加载 ELF 格式的用户程序二进制数据：
   - 创建新的内存管理结构（`mm_struct` 和页目录）。
   - 解析 ELF 文件头和程序头（program headers）。
   - 为每个可加载段（PT_LOAD）映射虚拟内存区域，设置权限（读、写、执行）。
   - 复制 TEXT/DATA 段的内容到内存，初始化 BSS 段为零。
   - 设置用户栈（USTACKTOP - USTACKSIZE）。
   - 更新当前进程的 `mm` 和页目录，切换地址空间（`lsatp`）。
   - 设置陷阱帧（trapframe）：设置栈指针（sp）、程序计数器（epc）和状态寄存器（status），准备从内核返回用户模式。

4. **切换到用户模式：** 设置完成后，进程从内核返回用户模式，开始执行用户程序的入口点（`elf->e_entry`）。

这个过程确保用户程序在隔离的用户地址空间中运行，内核通过页表管理内存保护。

**调试内核上运行的用户程序：**

是的，要调试用户程序，需要加载其符号表到 GDB 中。用户程序的符号信息存储在编译时生成的 `.sym` 文件中（例如，`obj/user/hello.sym`）。

**操作步骤：**

1. **编译用户程序：** 确保用户程序已编译，生成 `.sym` 文件（Makefile 中自动生成）。

2. **启动调试：** 使用 `make debug` 启动 QEMU（带 GDB 服务器），然后 `make gdb` 连接 GDB 并加载内核符号。

3. **加载用户程序符号：** 在 GDB 中，使用 `add-symbol-file` 命令加载用户程序的符号。例如，对于 `hello` 程序：
   ```
   (gdb) add-symbol-file obj/user/hello.sym 0x1000000
   ```
   这里 `0x1000000` 是用户程序的加载基地址（根据 `tools/user.ld` 中的配置）。你需要根据实际地址调整，或在程序运行时动态确定。

4. **设置断点：** 加载符号后，可以在用户程序的函数或行号上设置断点，例如 `b hello_main`（假设用户程序有 `hello_main` 函数）。

5. **调试：** 当内核加载用户程序后，断点会触发，允许单步调试用户代码。

注意：用户程序的地址空间与内核不同，确保 GDB 知道正确的地址映射。可以使用 `info files` 查看加载的文件。

**为什么 make debug 和 make gdb 会自动加载内核符号表：**

- `make debug`：启动 QEMU，加载内核镜像（`bin/kernel`），并启用 GDB 服务器（`-s -S`），监听端口 1234。

- `make gdb`：启动 GDB，并执行以下命令（在 Makefile 中定义）：
  - `-ex 'file bin/kernel'`：加载内核的可执行文件 `bin/kernel`，这会自动读取其调试符号（因为内核编译时包含 `-g` 标志）。
  - `-ex 'set arch riscv:rv64'`：设置架构为 RISC-V 64 位。
  - `-ex 'target remote localhost:1234'`：连接到 QEMU 的 GDB 服务器。

因此，`make gdb` 通过 `file bin/kernel` 自动加载内核符号表，因为内核二进制文件包含调试信息。用户程序符号需要手动加载，因为它们是独立的二进制文件。

## 调试会话 4

### 问题：Store/AMO page fault 出现多次，然后断点触发在用户空间的 syscall，怎么解决？

**调试输出：**
```
Store/AMO page fault
Store/AMO page fault
Store/AMO page fault
Store/AMO page fault

(gdb) c
Continuing.

Breakpoint 2, syscall (num=2) at user/libs/syscall.c:19    
19          asm volatile (
(gdb)
```

**解释：**

- **Store/AMO page fault：** 这些是存储/原子操作页面错误，继续之前的解释。在 lab5 的 COW（Copy-on-Write）实验中，这是正常的现象。当子进程（通过 fork 创建）尝试写入父进程共享的只读页面时，会触发页面错误，内核会复制该页面并更新映射。这是 COW 机制的核心，用于延迟复制直到实际写入。如果页面错误过多或导致崩溃，可能需要检查 COW 实现（在 `kern/mm/` 中的页面错误处理代码）。

- **断点触发：** 断点 2 在用户空间的 `user/libs/syscall.c:19` 触发，这是 `syscall` 函数的内联汇编部分（`asm volatile`），用于执行 `ecall` 指令进入内核。`num=2` 表示系统调用编号为 2，对应 `SYS_fork`（根据 `libs/unistd.h`）。这表明用户程序正在调用 `fork` 系统调用，可能是在测试进程创建和 COW。

**解决方法：**

1. **确认是否正常：** 在 COW 实验中，这些页面错误是预期的。如果程序继续运行并完成测试（如 `cow_test`），则无需担心。如果导致死循环或崩溃，检查内核的页面错误处理（`kern/trap/trap.c` 中的 `do_pgfault` 函数）和 COW 逻辑（`kern/mm/vmm.c` 或相关文件）。

2. **调试步骤：**
   - **继续执行：** 使用 `c`（continue）让程序运行，看是否完成。
   - **检查内核处理：** 在 GDB 中设置断点在内核的页面错误处理函数，如 `b do_pgfault`（在 `kern/trap/trap.c`），观察 COW 如何处理。
   - **单步调试用户程序：** 如果需要，加载用户程序符号（见调试会话 3），然后在用户代码中设置断点。
   - **查看内存：** 使用 GDB 命令如 `x` 检查页面内容，或 `info proc` 查看进程状态。

3. **如果问题持续：** 
   - 验证 COW 实现：确保在 `pgdir_alloc_page` 或 `do_pgfault` 中正确处理写时复制（复制页面、更新 PTE 为可写）。
   - 检查测试程序：运行 `make run-cow_test` 或类似，看输出是否符合预期。
   - 重启调试：如果内核状态混乱，重新 `make debug` 和 `make gdb`。

如果这是 COW 测试的一部分，页面错误后程序应正常继续；否则，提供更多输出以进一步诊断。

## 调试会话 5

### 问题：设置断点在 do_pgfault 后，继续执行触发页面错误处理，然后又回到 syscall，这个输出是什么意思？

**调试输出：**
```
(gdb) c
Continuing.

Breakpoint 2, syscall (num=2) at user/libs/syscall.c:19    
19          asm volatile (
(gdb) b do_pgfault
Breakpoint 3 at 0xffffffffc02039a6: file kern/mm/vmm.c, line 208.
(gdb) c           
Continuing.

Breakpoint 3, do_pgfault (mm=0xffffffffc04b6370,
    error_code=15, addr=2147483484) at kern/mm/vmm.c:208   
208         struct vma_struct *vma = find_vma(mm, addr);   
(gdb) c
Continuing.

Breakpoint 2, syscall (num=2) at user/libs/syscall.c:19    
19          asm volatile (
```

**解释：**

- **设置断点：** `b do_pgfault` 在 `kern/mm/vmm.c:208` 设置断点，这是页面错误处理函数的入口，用于处理 COW 等页面错误。

- **触发页面错误：** 继续执行后，断点 3 触发 `do_pgfault`，参数：
  - `mm=0xffffffffc04b6370`：当前进程的内存管理结构。
  - `error_code=15`：页面错误代码。在 RISC-V 中，15 (0b1111) 通常表示 Store/AMO page fault，即尝试写入只读页面（COW 场景）。
  - `addr=2147483484`：错误地址，十进制 2147483484 = 0x7fffefdc，大约在用户栈区域 (USTACKTOP 附近)，可能是栈上的变量被写入触发 COW。

- **处理后继续：** 执行 `c` 后，页面错误被处理（内核复制页面并更新权限），程序返回用户空间，又触发 syscall 断点（num=2，仍是 fork）。

这表明 COW 机制正在工作：用户程序（可能是子进程）尝试写入共享页面，触发页面错误，内核处理后继续执行。如果循环重复，可能是 fork 后多个写入操作。

**下一步调试建议：**
- **单步 do_pgfault：** 在断点 3 处，使用 `n` 或 `s` 单步执行，检查 `find_vma`、`pgdir_alloc_page` 等，确保 COW 逻辑正确（复制页面、设置 PTE_W）。
- **检查地址：** 使用 `p addr` 或 `x addr` 查看错误地址的内容。
- **查看进程：** `info proc` 或 `p current->pid` 确认是父/子进程。
- **如果异常：** 如果页面错误未正确处理，导致 panic，提供 `kern/mm/vmm.c` 的 do_pgfault 实现检查。

## 调试会话 6

### 问题：单步执行 do_pgfault 的过程，这个输出是什么意思？

**调试输出：**
```
(gdb) c
Continuing.

Breakpoint 3, do_pgfault (mm=0xffffffffc04b6370,
    error_code=15, addr=2147483484) at kern/mm/vmm.c:208   
208         struct vma_struct *vma = find_vma(mm, addr);   
(gdb) s
find_vma (mm=mm@entry=0xffffffffc04b6370, 
    addr=addr@entry=2147483484) at kern/mm/vmm.c:81        
81          if (mm != NULL)
(gdb) s
83              vma = mm->mmap_cache;
(gdb) s
84              if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr))
(gdb) s
104                 mm->mmap_cache = vma;
(gdb) s
do_pgfault (mm=0xffffffffc04b6370, 
    error_code=<optimized out>, addr=2147483484)
    at kern/mm/vmm.c:210
210         if (vma == NULL || vma->vm_start > addr) {     
(gdb) s
216         switch (error_code) {
(gdb) s
219                 if (!(vma->vm_flags & VM_WRITE)) {
(gdb) s
241         addr = ROUNDDOWN(addr, PGSIZE);
(gdb) s
247         if ((ptep = get_pte(mm->pgdir, addr, 1)) == NULL) {
(gdb) s
get_pte (pgdir=0xffffffffc04bc000, 
    la=la@entry=2147479552, create=create@entry=1)
    at kern/mm/pmm.c:223
223         pde_t *pdep1 = &pgdir[PDX1(la)];
(gdb) s
224         if (!(*pdep1 & PTE_V))
(gdb) s
237         pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
(gdb) s
238         if (!(*pdep0 & PTE_V))
(gdb) s
do_pgfault (mm=0xffffffffc04b6370, 
    error_code=<optimized out>, addr=2147479552)
    at kern/mm/vmm.c:253
253         if (*ptep == 0) {
(gdb) s
261             struct Page *page = pte2page(*ptep);
(gdb) s
pte2page (pte=538162195) at kern/mm/pmm.h:125
125         if (!(pte & PTE_V))
(gdb) s
129         return pa2page(PTE_ADDR(pte));
(gdb) s
pa2page (pa=2152648704) at kern/mm/pmm.h:103
103         if (PPN(pa) >= npage)
(gdb) s
0xffffffffc0203a78 in pa2page (pa=2152648704)
    at kern/mm/pmm.h:103
103         if (PPN(pa) >= npage)
(gdb) s
107         return &pages[PPN(pa) - nbase];
(gdb) s
do_pgfault (mm=0xffffffffc04b6370, 
    error_code=<optimized out>, addr=2147479552)
    at kern/mm/pmm.h:141
141         return page->ref;
(gdb) s
266                 if ((newpage = alloc_page()) == NULL) {
(gdb) s
alloc_pages (n=1) at kern/mm/pmm.c:57
57          local_intr_save(intr_flag);
(gdb) s
__intr_save () at kern/sync/sync.h:12
12          if (read_csr(sstatus) & SSTATUS_SIE)
(gdb) s
alloc_pages (n=1) at kern/mm/pmm.c:59
59              page = pmm_manager->alloc_pages(n);        
(gdb) s
default_alloc_pages (n=1) at kern/mm/default_pmm.c:108
108         assert(n > 0);
(gdb) s
109         if (n > nr_free)
(gdb) s
106     default_alloc_pages(size_t n)
(gdb) s
0xffffffffc020197a in default_alloc_pages (
    n=<optimized out>) at kern/mm/default_pmm.c:114        
114         list_entry_t *le = &free_list;
(gdb) s
115         while ((le = list_next(le)) != &free_list)
(gdb) s
list_next (listelm=0xffffffffc02b0f78 <free_area>)
    at libs/list.h:123
123         return listelm->next;
(gdb) s
118             if (p->property >= n)
(gdb) s
default_alloc_pages (n=<optimized out>)
    at kern/mm/default_pmm.c:127
127             list_del(&(page->page_link));
(gdb) s
0xffffffffc020199a in list_del (listelm=<optimized out>)
    at libs/list.h:93
93          __list_del(listelm->prev, listelm->next);      
(gdb) s
156         prev->next = next;
(gdb) s
127             list_del(&(page->page_link));
(gdb) s
list_del (listelm=0xffffffffc02c9d58) at libs/list.h:93
93          __list_del(listelm->prev, listelm->next);      
(gdb) s
0xffffffffc02019a6 in __list_del (
    next=0xffffffffc02b0f78 <free_area>,
    prev=0xffffffffc02b0f78 <free_area>)
    at libs/list.h:156
156         prev->next = next;
(gdb) s
157         next->prev = prev;
(gdb) s
default_alloc_pages (n=<optimized out>)
    at kern/mm/default_pmm.c:128
128             if (page->property > n)
(gdb) s
130                 struct Page *p = page + n;
(gdb) s
131                 p->property = page->property - n;
(gdb) s
132                 SetPageProperty(p);
(gdb) s
set_bit (addr=0xffffffffc02c9d88, nr=1)
    at libs/atomic.h:61
61          __op_bit(or, __NOP, nr, ((volatile unsigned long *)addr));
(gdb) s
default_alloc_pages (n=<optimized out>)
    at kern/mm/default_pmm.c:128
128             if (page->property > n)
(gdb) s
130                 struct Page *p = page + n;
(gdb) s
131                 p->property = page->property - n;
(gdb) s
132                 SetPageProperty(p);
(gdb) s
set_bit (addr=0xffffffffc02c9d88, nr=1)
    at libs/atomic.h:61
61          __op_bit(or, __NOP, nr, ((volatile unsigned long *)addr));
(gdb) s
default_alloc_pages (n=<optimized out>)
    at kern/mm/default_pmm.c:133
133                 list_add(prev, &(p->page_link));   
```

**解释：**

这个单步调试展示了 `do_pgfault` 处理 COW（Copy-on-Write）页面错误的完整流程：

1. **查找 VMA：** `find_vma` 检查地址是否在有效的虚拟内存区域（VMA）内，使用缓存加速。

2. **检查错误类型：** `error_code=15` (Store fault)，确认 VMA 有写权限 (`VM_WRITE`)。

3. **获取 PTE：** `get_pte` 遍历页表找到页表项（PTE），地址向下对齐到页面边界。

4. **检查 PTE：** `*ptep != 0` 表示页面已映射，但可能是只读（COW 共享页面）。

5. **获取原页面：** `pte2page` 和 `pa2page` 从 PTE 提取物理页面。

6. **分配新页面：** `alloc_page` 调用 `default_alloc_pages`，从空闲列表分配新页面（涉及链表操作、属性设置）。

这是在执行 COW：原页面是共享的只读，写入时分配新页面，稍后会复制内容并更新 PTE 为可写。输出显示分配成功，没有错误。

**下一步：** 继续单步，观察页面复制 (`memcpy`) 和 PTE 更新 (`set_pte`)。如果一切正常，页面错误处理完成后应返回用户空间。

## 调试会话 7

### 问题：在执行 ecall 和 sret 这类汇编指令的时候，QEMU 进行了很关键的一步——指令翻译（TCG Translation），了解一下这个功能，思考一下另一个双重 gdb 调试的实验是否也涉及到了一些相关的内容。

**TCG (Tiny Code Generator) 功能解释：**

TCG 是 QEMU 的核心组件，用于动态二进制翻译。它将目标架构（如 RISC-V）的指令序列翻译成宿主架构（如 x86 或 ARM）的本地指令块（translation blocks），然后执行这些块。这允许 QEMU 在不同硬件上模拟目标系统，而无需硬件支持。

- **翻译过程：**
  - QEMU 解释执行目标指令，遇到新代码时，将其翻译成 TCG 中间表示（IR）。
  - TCG IR 被优化并编译成宿主机器码。
  - 执行翻译后的代码块，直到遇到跳转或异常。
  - 对于特权指令，如 ecall（环境调用，触发系统调用）和 sret（监督者返回，从异常返回），TCG 会模拟其行为：
    - **ecall**：模拟从用户模式到监督者模式的切换，保存上下文，跳转到异常处理向量（在操作系统中是 syscall 处理）。
    - **sret**：模拟从监督者模式返回用户模式，恢复上下文。

- **关键作用：** TCG 确保指令语义正确，包括特权级别、内存访问和异常处理。在 lab5 中，这支持内核/用户模式切换的模拟。

**思考双重 GDB 调试实验的相关性：**

双重 GDB 调试可能指同时调试 QEMU 模拟的内核和用户程序，或使用两个 GDB 会话（一个连接 QEMU，一个调试 QEMU 本身）。TCG 确实涉及相关内容：

- **调试映射：** TCG 翻译后的代码与原始目标代码不直接对应。QEMU 的 GDB 服务器（如 `-s -S`）需要将宿主地址映射回目标地址，确保断点和单步在目标代码中正确工作。
- **符号加载：** 如前所述，内核符号自动加载，用户符号需手动。TCG 确保调试器看到的是目标架构的执行流，即使底层是翻译的。
- **双重调试：** 如果“双重”指调试 QEMU 进程本身（使用另一个 GDB 附加到 QEMU），则 TCG 的翻译块和 IR 可能影响调试 QEMU 内部状态。但在标准 OS 实验中，双重调试更可能指内核+用户调试，TCG 通过地址翻译支持符号正确解析。
- **相关实验：** 在类似 lab5 的实验中，双重调试可能涉及加载用户符号并在 syscall 断点处切换上下文。TCG 确保 ecall/sret 的模拟准确，支持这种调试。

如果双重调试实验具体指某个场景，提供更多细节可进一步分析。

## 调试会话 8

### 问题：在 AI 帮助下完成整个调试流程，观察 ecall 和 sret 指令如何被 QEMU 处理，并简单阅读调试中涉及的 QEMU 源码，解释关键流程。

**完整调试流程总结（基于 AI 辅助）：**

1. **设置环境：** 使用 `make debug` 启动 QEMU（带 GDB 服务器），`make gdb` 连接 GDB 并加载内核符号。

2. **设置断点：** 在内核 syscall 和用户 syscall 设置断点，观察 ecall 触发。

3. **触发 ecall：** 用户程序执行 `ecall`，QEMU 模拟系统调用，切换到内核。

4. **处理页面错误：** 如果涉及 COW，单步 `do_pgfault`，观察页面分配和复制。

5. **返回用户：** 内核处理后执行 `sret`，QEMU 模拟返回用户模式。

6. **观察输出：** 记录 Store/AMO page fault 和断点触发，确认 COW 正常。

**ecall 和 sret 指令在 QEMU 中的处理：**

QEMU 使用 TCG 动态翻译这些特权指令。ecall 触发异常，sret 返回。

- **ecall 处理：**
  - 解码：识别为系统调用。
  - TCG：生成 `gen_exception` 或调用 helper `gen_ecall`。
  - 模式切换：保存 PC 到 sepc，设置 scause，跳转到 stvec（异常向量）。

- **sret 处理：**
  - 解码：识别为返回指令。
  - TCG：调用 helper 检查权限，恢复 PC 从 sepc。
  - 模式切换：从 S 模式返回 U 模式，更新 sstatus。

**QEMU 源码关键流程（简单阅读）：**

QEMU 源码（GitHub: qemu/qemu）中，RISC-V 相关在 `target/riscv/`：

1. **指令翻译（`target/riscv/translate.c`）：**
   - `decode_opc` 解码指令。
   - 对于 ecall：`gen_exception(EXCP_ECALL)`。
   - 对于 sret：`gen_sret()`，检查 sstatus SPP。

2. **Helper 函数（`target/riscv/op_helper.c`）：**
   - `riscv_cpu_do_interrupt`：处理异常，设置 CSR，切换模式。
   - `helper_sret`：恢复上下文，返回用户模式。

3. **TCG 执行（`tcg/`）：**
   - 翻译块生成宿主代码，执行时模拟硬件行为。

调试中，GDB 通过 QEMU 的 GDB stub 映射地址，确保符号正确。AI 帮助模拟流程，解释源码逻辑，无需实际修改 QEMU。
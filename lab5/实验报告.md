# 用户进程

小组成员：
- 2310648 高景珩
- 2313892 章昊

---

## 实验目的

- 了解第一个用户进程创建过程
- 了解系统调用框架的实现机制
- 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理

---

## 实验内容

### 练习0：填写已有实验

在本阶段，除了进行lab 2/3/4 的迁移，我们还进行了一些相关的代码升级，主要内容是：

1. 对lab3中的IRQ_S_TIMER中断处理函数改为下面的代码：
```c
case IRQ_S_TIMER:
    clock_set_next_event();
    ticks++;
    if (ticks == TICK_NUM) {
        print_ticks();
        print_num++;
        ticks = 0;
        assert(current != NULL);
        current->need_resched = 1;// 让当前进程在时钟中断后重新调度
    }
    if (print_num == 10) {
        sbi_shutdown();
    }
    break;
```
这里的主要目的是实现内核的抢占式调度机制。通过在时钟中断处理函数中设置 current->need_resched = 1，可以让当前进程在时钟中断后主动让出 CPU，进入调度流程，从而实现进程的时间片轮转。这样可以保证多个进程能够公平地获得 CPU 执行权，避免单个进程长时间占用 CPU 导致其他进程无法运行。该机制对于后续用户进程的并发执行和进程管理至关重要，是多进程操作系统的基础。

值得注意的是，需要将`current->need_resched = 1;`放在时钟中断处理函数的`if (ticks == TICK_NUM)`块最后部分，以确保在处理完所有时钟相关的逻辑后再进行调度请求。这样一方面可以避免在处理中途切换进程，导致状态不一致或资源竞争的问题；另一方面也可以降低调度的频率，减少不必要的上下文切换开销，提高系统整体性能。

2. 对lab4，我们修改了`static struct proc_struct *alloc_proc(void)`函数，添加了下面的部分
```c
proc->wait_state = 0;
proc->cptr = NULL;
proc->yptr = NULL;
proc->optr = NULL;
```
这是为了初始化一些新增的进程控制块字段，这些字段用于进程间通信和同步。

3. 对lab4，我们更新了`do_fork`函数：

- 阶段一改为：
```c
// 1. call alloc_proc to allocate a proc_struct, set parent and clear current wait_state
if ((proc = alloc_proc()) == NULL) {
    goto fork_out;
}
proc->parent = current;
current->wait_state = 0;
```
目的是确保新分配的进程控制块（proc_struct）能够正确地记录父进程信息，并初始化等待状态。通过调用 alloc_proc 分配新的进程结构体后，设置 proc->parent = current，可以建立父子进程关系，方便后续进程管理和资源回收。同时，清除当前进程的 wait_state，保证进程在 fork 操作后处于可运行状态，避免因遗留的等待标志导致调度异常。这些初始化操作为后续进程的调度、同步和管理打下了基础。

- 阶段五改为：
```c
// 5. insert proc_struct into hash_list && proc_list, and set relation links
proc->pid = get_pid();
hash_proc(proc);
set_links(proc);
``` 
其中，新增的set_links函数用于将进程加入到双向链表，并设置进程之间的父子关系和兄弟关系：
```c
static void
set_links(struct proc_struct *proc)
{
    list_add(&proc_list, &(proc->list_link));
    proc->yptr = NULL;
    if ((proc->optr = proc->parent->cptr) != NULL)
    {
        proc->optr->yptr = proc;
    }
    proc->parent->cptr = proc;
    nr_process++;
}
```

---

### 练习1: 加载应用程序并执行（需要编码）
*补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。在实验报告中简要说明你的设计实现过程。*
*请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。*

load_icode 函数的作用是将用户态应用程序（ELF 格式二进制）加载到当前进程的内存空间，并完成进程运行所需的各项初始化。其主要流程包括：为进程分配新的内存管理结构（mm_struct）、建立页表、解析 ELF 文件并将各个段（代码段、数据段、BSS 段）映射到用户空间、分配用户栈空间、设置进程的 mm 和页表指针，最后初始化 trapframe 以便进程能够从用户程序入口正确开始执行。

在第六步中，我补充了 trapframe 的初始化代码。具体做法是：首先将 trapframe 清零，然后设置 tf->gpr.sp 为用户栈顶（USTACKTOP），保证用户进程启动时栈指针正确；设置 tf->epc 为 ELF 文件的入口地址（elf->e_entry），确保进程从应用程序的第一条指令开始执行；最后设置 tf->status，清除 SSTATUS_SPP（使进程从用户态返回），并设置 SSTATUS_SPIE（使用户态中断使能），保证进程能够安全地从内核态切换到用户态运行。这些设置确保了进程在被调度后能够以正确的 CPU 状态进入用户空间，执行用户程序。

关于“用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的整个经过”，流程如下：当调度器选择某个用户进程进入 RUNNING 态时，内核会根据该进程的 trapframe 内容恢复 CPU 寄存器，包括栈指针（sp）、程序计数器（epc）、以及 sstatus 等关键寄存器。随后通过 sret 指令从内核态切换到用户态，CPU 跳转到 trapframe 中设置的 epc 地址，即应用程序的入口点，开始执行用户代码。整个过程依赖于 trapframe 的正确设置，保证了进程能够从内核安全地切换到用户空间，并从应用程序的第一条指令开始运行。

综上，load_icode 的设计实现保证了用户程序能够被正确加载到内存，并通过 trapframe 的精确初始化，使进程能够顺利从内核态切换到用户态，开始执行用户代码。这是用户进程创建和启动的核心环节，也是操作系统实现多进程管理的基础。

---

### 练习2: 父进程复制自己的内存空间给子进程（需要编码）
*创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。请在实验报告中简要说明你的设计实现过程。*
*如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。*

在本实验中，do_fork 函数用于创建子进程，其核心步骤之一是复制父进程的用户内存空间到子进程。具体实现是通过 copy_range 函数完成的。copy_range 会遍历父进程的页表，将每一页的内容复制到新分配的物理页，并建立子进程页表的映射关系。这样可以保证子进程拥有与父进程相同的用户空间内容，实现进程地址空间的独立性。

copy_range 实现思路如下：首先遍历指定的虚拟地址区间，查找父进程的页表项（PTE），如果该页有效，则为子进程分配新物理页，并用 memcpy 将父进程页的内容复制到新页。然后通过 page_insert 将新页映射到子进程的页表中，权限位（perm）也会根据父进程页表项进行设置。这样，子进程获得了与父进程一致的内存内容，但物理页是独立分配的，互不影响。

```c
uintptr_t src_kvaddr = (uintptr_t)page2kva(page);
uintptr_t dst_kvaddr = (uintptr_t)page2kva(npage);
memcpy((void *)dst_kvaddr, (void *)src_kvaddr, PGSIZE);
ret = page_insert(to, npage, start, perm);
```
这四行代码实现了父进程到子进程用户空间的页级内容复制。首先通过 page2kva(page) 和 page2kva(npage) 分别获取父进程和子进程物理页的内核虚拟地址，然后用 memcpy 将父页的内容完整复制到新分配的子页。最后，调用 page_insert 将新页映射到子进程的页表，并设置相应的权限。这样做的好处是保证了子进程获得与父进程一致的内存内容，同时物理页是独立分配的，避免了进程间的内存干扰，为后续的进程隔离和资源管理打下了基础。整个过程简洁高效，充分利用了内核的页管理和映射机制。

Copy on Write（COW）机制设计概要：
- COW 机制的核心思想是：在 fork 时，父子进程共享物理页，只有在某一方试图写入该页时，才进行物理页的复制。具体设计如下：
- fork 时，不直接复制物理页，而是将页表项的写权限去掉，并设置 COW 标志（可用自定义 PTE 标志位）。
父子进程页表都指向同一物理页，且该页的引用计数加一。
当某进程写入该页时，触发页异常（page fault），内核检测到 COW 标志后，为该进程分配新物理页，将原页内容复制过去，更新页表为可写，并清除 COW 标志，原页引用计数减一。
这样只有在实际写入时才分配新页，显著减少 fork 时的物理内存消耗，提高系统效率。

---

### 练习3:阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
*请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？*
*请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）*

fork/exec/wait/exit 的执行流程分析：

1. fork
用户态进程通过系统调用 sys_fork 进入内核，内核在 do_fork（proc.c）中完成子进程的创建。主要步骤包括：分配并初始化 proc_struct（alloc_proc）、分配内核栈（setup_kstack）、复制或共享内存空间（copy_mm，实际复制由 copy_range 完成）、设置 trapframe 和上下文（copy_thread），最后将新进程加入进程链表并唤醒（set_links、wakeup_proc）。fork 的返回值通过 trapframe 传递回用户态，父进程获得子进程 pid，子进程获得 0。

2. exec
用户态进程通过 sys_exec 系统调用进入内核，内核在 do_execve（proc.c）中回收原有内存空间（exit_mmap、put_pgdir），调用 load_icode 加载新的用户程序（解析 ELF，分配内存，设置 trapframe），并更新进程名。exec 的结果通过 trapframe 返回，用户态进程从新程序入口开始执行。

3. wait
用户态进程通过 sys_wait 进入内核，内核在 do_wait（proc.c）中遍历子进程链表，查找处于 ZOMBIE 状态的子进程，回收其资源（unhash_proc、remove_links、put_kstack、kfree），并将退出码返回给用户态。如果没有可回收的子进程，则当前进程进入 SLEEPING 状态，等待唤醒。

4. exit
用户态进程通过 sys_exit 进入内核，内核在 do_exit（proc.c）中释放进程内存空间（exit_mmap、put_pgdir、mm_destroy），设置进程状态为 ZOMBIE，保存退出码，唤醒父进程（wakeup_proc），并调用调度器切换到其他进程（schedule）。资源最终由父进程 wait 时回收。

用户态与内核态的交错执行：
所有上述操作的入口均为用户态系统调用，触发 trap 进入内核态，内核完成实际资源管理和状态变更。内核态通过 trapframe 将结果（如返回值、错误码）写回，trap 返回后用户态进程继续执行。进程调度、状态切换、资源分配与回收均在内核态完成，用户态仅负责发起请求和接收结果。

内核态执行结果返回机制：
内核通过修改 trapframe（如 a0/a1 等寄存器）将系统调用返回值传递给用户态。trap 返回时，CPU 恢复 trapframe 内容，用户态进程从系统调用返回点继续执行，获得内核操作结果。

ucore 用户态进程执行状态生命周期图：
```
+------------------+         fork/execve         +------------------+
|  PROC_UNINIT     |---------------------------> |  PROC_RUNNABLE   |
+------------------+                             +------------------+
         ^                                               |
         |                                               | schedule
         |                                               v
         |                                       +------------------+
         |                                       |  PROC_SLEEPING   |
         |                                       +------------------+
         |                                               ^
         |                                               | wakeup_proc
         |                                               |
         |                                       +------------------+
         |                                       |  PROC_ZOMBIE     |
         |<------------------- do_exit ---------- +------------------+
         |                                               |
         |<------------------- do_wait ------------------+
```

状态变换事件/函数：
- PROC_UNINIT → PROC_RUNNABLE：fork/execve 创建进程
- PROC_RUNNABLE → PROC_SLEEPING：do_wait/do_sleep 等待事件
- PROC_SLEEPING → PROC_RUNNABLE：wakeup_proc 唤醒进程
- PROC_RUNNABLE → PROC_ZOMBIE：do_exit 进程退出
- PROC_ZOMBIE → 资源回收：do_wait 回收资源并删除进程

### 扩展练习 Challenge

#### 实现 Copy on Write （COW）机制

Copy-On-Write（写时复制，COW）是一种高效的进程间资源共享优化技术。在传统的fork实现中，子进程创建时需要完整复制父进程的全部内存内容，这会造成大量的内存开销和时间消耗。COW机制通过延迟复制时机，只有在进程真正需要修改共享页面时才执行实际的复制操作，从而显著提高了系统性能。

**核心设计思想**

COW的实现基于三个关键机制：第一，fork时父子进程共享物理页面而不是立即复制，通过清除页表项的写权限标志位（PTE_W）使所有共享页面变为只读；第二，利用物理页面的引用计数（ref_count）追踪有多少个进程正在使用该页面；第三，当任一进程尝试写入共享页面时，处理器产生页面写故障（Store Page Fault），内核捕获该故障并根据引用计数决定是复制页面还是直接恢复写权限。

**实现的三个核心阶段**

1. **fork阶段的共享建立（copy_range函数）**

在`copy_range`函数中，当`share`参数为true时，不再完整复制页面内容，而是建立共享关系。关键代码如下：

```c
if (share) {
    // COW模式：建立共享映射，清除写权限
    page_insert(from, page, start, perm & ~PTE_W);  // 父进程页表标记为只读
    ret = page_insert(to, page, start, perm & ~PTE_W);  // 子进程页表标记为只读
}
```

通过`perm & ~PTE_W`清除写权限标志位，使父子进程的页表项都指向同一物理页面但都是只读的。`page_insert()`函数在建立映射时会自动增加该页面的引用计数，因此共享后引用计数变为2。

2. **异常处理阶段（exception_handler）**

当进程尝试写入只读页面时，处理器产生页面写故障异常。异常处理器捕获CAUSE_STORE_PAGE_FAULT或CAUSE_STORE_ACCESS事件，调用`do_pgfault()`进行处理：

```c
case CAUSE_STORE_PAGE_FAULT:
    if ((ret = do_pgfault(current->mm, tf->cause, tf->tval)) != 0) {
        print_trapframe(tf);
        do_exit(ret);
    }
    break;
```

3. **延迟复制阶段（do_pgfault函数）**

`do_pgfault()`是COW的核心处理函数。它首先验证故障地址的有效性和权限，然后根据页面的引用计数采取不同策略：

```c
if (*ptep == 0) {
    // 真正缺页，分配新页面
    pgdir_alloc_page(mm->pgdir, addr, perm);
} else {
    struct Page *page = pte2page(*ptep);
    if (page_ref(page) > 1) {
        // 引用计数>1，多个进程共享，需要复制
        struct Page *newpage = alloc_page();
        memcpy(page2kva(newpage), page2kva(page), PGSIZE);
        page_insert(mm->pgdir, newpage, addr, perm);
    } else {
        // 引用计数=1，只有当前进程使用，直接恢复写权限
        page_insert(mm->pgdir, page, addr, perm);
    }
}
```

这里的优化非常关键：当引用计数为1时（说明其他进程已经各自复制了副本），可以直接在原页面上恢复写权限而无需复制，避免了不必要的内存操作。

**性能优势分析**

COW机制带来显著的性能提升。在fork时，传统方式需要O(n×PGSIZE)的内存复制时间，而COW只需O(n)的页表处理时间。更重要的是，许多场景下fork后会立即执行exec加载新程序，此时共享的内存页面会被完全丢弃而无需复制。即使不执行exec，通常也只有部分页面会被修改，COW只复制真正需要的页面，大幅减少了内存消耗和复制开销。

**状态转换机制**

COW机制下，物理页面经历以下状态：初始状态（Shared Read-Only，引用计数≥2）→ 写触发状态（Write Fault）→ 转换状态（Copy and Protect或Direct Grant）→ 独占状态（Exclusive Writable，引用计数=1）。这个状态机通过引用计数驱动，保证了进程独立性和资源高效利用的平衡。

本实现完整展示了COW机制的核心思想和技术细节，为理解现代操作系统的内存管理优化提供了实践基础。通过延迟复制、引用计数管理和页表权限控制的协同工作，COW在保证进程隔离性的同时，最大限度地提高了系统的内存利用效率和fork操作的性能。

#### 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？

**用户程序的加载时机与流程**

在ucore中，用户程序是在系统初始化的早期阶段通过特殊的编译链接方式被"预先"加载到内核镜像中的，具体流程如下：

1. **编译时期的静态链接**：在编译阶段，用户程序（如exit.c、fork.c等）被编译成ELF格式的二进制文件，然后通过特殊的链接脚本将这些用户程序的二进制数据作为全局数组符号嵌入到内核镜像中。例如，`_binary_obj___user_exit_out_start`和`_binary_obj___user_exit_out_size`等符号直接指向用户程序的二进制内容和大小。

2. **内核启动时的内存布局**：当内核启动时，整个内核镜像（包括嵌入的用户程序二进制）被bootloader加载到物理内存中。此时用户程序以二进制数据的形式存在于内核的数据段中，但尚未被加载到任何进程的用户空间。

3. **进程初始化阶段的动态加载**：在`proc_init()`函数中，系统创建了第一个内核线程idle和第二个内核线程init。init线程执行`init_main()`函数，该函数创建`user_main`内核线程，`user_main`通过`KERNEL_EXECVE`宏调用`kernel_execve()`函数，将预先嵌入内核的用户程序二进制数据通过`load_icode()`函数解析ELF格式并加载到当前进程的用户空间。此时才真正将用户程序的代码段、数据段等映射到用户进程的虚拟地址空间，并设置好trapframe使进程能够从用户态入口开始执行。

具体代码流程为：
```c
// proc_init() → kernel_thread(init_main) → init_main()
int pid = kernel_thread(user_main, NULL, 0);  // 创建user_main线程

// user_main() → KERNEL_EXECVE(exit) → kernel_execve()
kernel_execve(name, binary, size);  // binary指向嵌入内核的用户程序

// kernel_execve() → do_execve() → load_icode()
load_icode(binary, size);  // 解析ELF并加载到用户空间
```

**与常用操作系统的区别**

与Linux、Windows等通用操作系统相比，ucore的用户程序加载方式存在显著差异：

1. **加载时机的差异**：
   - **ucore**：用户程序在编译时静态链接到内核镜像中，随内核一起加载到内存。用户程序的二进制数据在系统启动时就已经在内存中，只是尚未映射到用户空间。
   - **通用OS**：用户程序存储在磁盘文件系统中（如ext4、NTFS），只有在用户执行程序时（如运行`./program`），操作系统才从磁盘读取ELF文件并加载到内存。通常采用按需加载（demand paging），只加载程序的必要部分，其余部分在访问时再从磁盘读取。

2. **存储位置的差异**：
   - **ucore**：用户程序嵌入在内核镜像的数据段中，与内核代码、数据共享同一块物理内存区域。用户程序的数量和大小在编译时就已确定，无法动态添加新程序。
   - **通用OS**：用户程序作为独立文件存储在持久化的文件系统中，可以动态安装、更新、删除程序，不受内核大小限制。

3. **加载机制的差异**：
   - **ucore**：通过`load_icode()`直接从内存中的二进制数据解析ELF格式，一次性将所有段加载到用户空间，不涉及磁盘I/O操作。
   - **通用OS**：通过系统调用（如`execve()`）打开磁盘文件，读取ELF头部，创建VMA，通常采用延迟加载策略，只在页面首次访问时才从磁盘读取数据到内存（通过page fault机制）。

综上所述，ucore的用户程序加载机制是一种针对教学场景优化的简化设计。它牺牲了灵活性和可扩展性，换取了实现的简单性和教学的聚焦性。这种设计使得学生能够在理解核心操作系统概念的同时，避免陷入过多实现细节的困扰，为后续学习更复杂的文件系统和动态加载机制打下基础。

---

## 知识点总结

本实验涵盖了操作系统中用户进程管理的核心知识点，主要包括以下几个方面：

### 1. 用户进程的创建与执行

- **进程控制块（PCB）**：理解`struct proc_struct`的各个字段含义，包括进程状态、PID、内核栈、页表指针、trapframe、上下文等，掌握进程管理的基本数据结构。
- **进程的生命周期**：掌握进程从UNINIT→RUNNABLE→RUNNING→SLEEPING→ZOMBIE的状态转换，理解各状态转换的触发条件和相关函数（如alloc_proc、wakeup_proc、do_exit等）。
- **ELF文件加载**：理解ELF（Executable and Linkable Format）文件格式，掌握`load_icode()`函数如何解析ELF文件并将代码段、数据段、BSS段加载到用户空间的过程。
- **trapframe的作用**：理解trapframe作为进程上下文保存机制的核心作用，掌握如何通过设置trapframe实现内核态到用户态的切换。

### 2. 系统调用机制

- **系统调用接口**：理解用户态通过`ecall`指令触发异常进入内核态，内核通过`syscall()`函数分发系统调用的过程。
- **系统调用的实现**：掌握sys_fork、sys_exec、sys_wait、sys_exit等关键系统调用的实现原理，理解用户态与内核态的协作机制。
- **参数传递与返回值**：理解系统调用如何通过寄存器（如a0-a7）传递参数和返回结果，掌握trapframe在参数传递中的作用。

### 3. 进程间的父子关系与进程树

- **进程关系链表**：理解cptr（child pointer）、yptr（younger sibling）、optr（older sibling）等字段构成的进程树结构，掌握`set_links()`函数如何维护进程间关系。
- **父进程与子进程**：理解fork时父子进程的内存空间复制（或共享）关系，掌握do_fork函数的完整流程。
- **进程回收机制**：理解ZOMBIE状态的作用，掌握父进程通过wait回收子进程资源的机制，理解孤儿进程如何被init进程接管。

### 4. 内存管理与地址空间

- **虚拟内存区域（VMA）**：掌握`struct vma_struct`的作用，理解VMA如何描述进程地址空间的不同区域（代码段、数据段、堆、栈等）及其权限。
- **页表管理**：理解二级页表结构，掌握`get_pte()`、`page_insert()`等函数的作用，理解虚拟地址到物理地址的转换过程。
- **用户栈与内核栈**：理解用户栈（USTACKTOP）和内核栈（kstack）的区别和作用，掌握栈的初始化和使用方式。

### 5. 内存复制与写时复制（COW）

- **传统内存复制**：理解`copy_range()`函数如何在fork时复制父进程的内存页面到子进程，掌握页面级别的内存复制机制。
- **COW优化机制**：理解写时复制的核心思想，掌握如何通过页表权限控制（清除PTE_W）和引用计数（ref_count）实现延迟复制。
- **页面故障处理**：理解Store Page Fault的触发机制，掌握`do_pgfault()`函数如何根据引用计数决定是复制页面还是直接恢复写权限。
- **性能优化思想**：理解COW如何通过延迟操作减少不必要的内存复制，掌握引用计数优化（ref_count=1时直接赋予写权限）的原理。

### 6. 进程调度与时间片

- **抢占式调度**：理解时钟中断如何通过设置`need_resched`标志触发进程调度，掌握时间片轮转的基本原理。
- **调度器的作用**：理解`schedule()`函数如何选择下一个运行的进程，掌握进程上下文切换（context switch）的机制。
- **idle进程**：理解idle进程作为系统空闲时运行的特殊进程的作用，掌握CPU空闲时的调度策略。

### 7. 用户态与内核态的切换

- **特权级切换**：理解RISC-V的S态（内核态）和U态（用户态）的区别，掌握通过`sret`指令从内核态返回用户态的机制。
- **异常与中断处理**：理解`exception_handler()`和`interrupt_handler()`的作用，掌握不同类型异常的处理流程。
- **上下文保存与恢复**：理解trapframe如何保存和恢复CPU寄存器状态，掌握上下文切换的完整过程。

### 8. 进程同步与等待机制

- **等待状态管理**：理解`wait_state`字段的作用，掌握do_wait如何让父进程等待子进程退出。
- **进程唤醒机制**：理解`wakeup_proc()`函数如何将SLEEPING状态的进程唤醒到RUNNABLE状态，掌握进程间的同步协作。
- **退出与资源回收**：理解`do_exit()`如何释放进程资源，掌握进程退出的完整流程。

### 9. 用户程序的加载方式

- **静态链接与嵌入**：理解ucore如何在编译时将用户程序嵌入到内核镜像中，掌握`KERNEL_EXECVE`宏的工作原理。
- **与通用OS的对比**：理解ucore的简化设计与Linux等通用操作系统在用户程序加载方式上的差异，认识到教学OS与生产OS在设计权衡上的不同考虑。
- **按需加载的概念**：理解现代操作系统中按需加载（demand paging）的基本思想，为后续学习文件系统和虚拟内存管理打下基础。

### 10. 操作系统设计哲学

- **抽象与封装**：理解操作系统如何通过进程抽象为用户程序提供独立的执行环境，掌握系统调用接口作为抽象层的作用。
- **性能与简洁的权衡**：通过COW机制理解操作系统在性能优化与实现复杂度之间的权衡，认识到优化的必要性和代价。
- **教学简化的必要性**：理解ucore作为教学OS在设计上的简化策略，认识到循序渐进学习的重要性。

通过本实验，深入理解了操作系统如何管理和调度用户进程，掌握了从进程创建、内存管理、系统调用到进程同步等一系列核心机制。特别是COW机制的实现，展示了现代操作系统在性能优化方面的智慧。这些知识为理解更复杂的操作系统功能（如线程、文件系统、设备驱动等）奠定了坚实的基础。

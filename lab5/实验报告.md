# 用户进程

小组成员：
- 2310648 高景珩
- 2313892 章昊

---

## 实验目的

- 了解第一个用户进程创建过程
- 了解系统调用框架的实现机制
- 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理

---

## 实验内容

### 练习0：填写已有实验

在本阶段，除了进行lab 2/3/4 的迁移，我们还进行了一些相关的代码升级，主要内容是：

1. 对lab3中的IRQ_S_TIMER中断处理函数改为下面的代码：
```c
case IRQ_S_TIMER:
    clock_set_next_event();
    ticks++;
    if (ticks == TICK_NUM) {
        print_ticks();
        print_num++;
        ticks = 0;
        assert(current != NULL);
        current->need_resched = 1;// 让当前进程在时钟中断后重新调度
    }
    if (print_num == 10) {
        sbi_shutdown();
    }
    break;
```
这里的主要目的是实现内核的抢占式调度机制。通过在时钟中断处理函数中设置 current->need_resched = 1，可以让当前进程在时钟中断后主动让出 CPU，进入调度流程，从而实现进程的时间片轮转。这样可以保证多个进程能够公平地获得 CPU 执行权，避免单个进程长时间占用 CPU 导致其他进程无法运行。该机制对于后续用户进程的并发执行和进程管理至关重要，是多进程操作系统的基础。

2. 对lab4，我们修改了`static struct proc_struct *alloc_proc(void)`函数，添加了下面的部分
```c
proc->wait_state = 0;
proc->cptr = NULL;
proc->yptr = NULL;
proc->optr = NULL;
```
这是为了初始化一些新增的进程控制块字段，这些字段用于进程间通信和同步。

3. 对lab4，我们更新了`do_fork`函数：

- 阶段一改为：
```c
// 1. call alloc_proc to allocate a proc_struct, set parent and clear current wait_state
if ((proc = alloc_proc()) == NULL) {
    goto fork_out;
}
proc->parent = current;
current->wait_state = 0;
```
目的是确保新分配的进程控制块（proc_struct）能够正确地记录父进程信息，并初始化等待状态。通过调用 alloc_proc 分配新的进程结构体后，设置 proc->parent = current，可以建立父子进程关系，方便后续进程管理和资源回收。同时，清除当前进程的 wait_state，保证进程在 fork 操作后处于可运行状态，避免因遗留的等待标志导致调度异常。这些初始化操作为后续进程的调度、同步和管理打下了基础。

- 阶段五改为：
```c
// 5. insert proc_struct into hash_list && proc_list, and set relation links
proc->pid = get_pid();
hash_proc(proc);
set_links(proc);
``` 
其中，新增的set_links函数用于将进程加入到双向链表，并设置进程之间的父子关系和兄弟关系：
```c
static void
set_links(struct proc_struct *proc)
{
    list_add(&proc_list, &(proc->list_link));
    proc->yptr = NULL;
    if ((proc->optr = proc->parent->cptr) != NULL)
    {
        proc->optr->yptr = proc;
    }
    proc->parent->cptr = proc;
    nr_process++;
}
```

---

### 练习1: 加载应用程序并执行（需要编码）
*补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。在实验报告中简要说明你的设计实现过程。*
*请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。*

load_icode 函数的作用是将用户态应用程序（ELF 格式二进制）加载到当前进程的内存空间，并完成进程运行所需的各项初始化。其主要流程包括：为进程分配新的内存管理结构（mm_struct）、建立页表、解析 ELF 文件并将各个段（代码段、数据段、BSS 段）映射到用户空间、分配用户栈空间、设置进程的 mm 和页表指针，最后初始化 trapframe 以便进程能够从用户程序入口正确开始执行。

在第六步中，我补充了 trapframe 的初始化代码。具体做法是：首先将 trapframe 清零，然后设置 tf->gpr.sp 为用户栈顶（USTACKTOP），保证用户进程启动时栈指针正确；设置 tf->epc 为 ELF 文件的入口地址（elf->e_entry），确保进程从应用程序的第一条指令开始执行；最后设置 tf->status，清除 SSTATUS_SPP（使进程从用户态返回），并设置 SSTATUS_SPIE（使用户态中断使能），保证进程能够安全地从内核态切换到用户态运行。这些设置确保了进程在被调度后能够以正确的 CPU 状态进入用户空间，执行用户程序。

关于“用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的整个经过”，流程如下：当调度器选择某个用户进程进入 RUNNING 态时，内核会根据该进程的 trapframe 内容恢复 CPU 寄存器，包括栈指针（sp）、程序计数器（epc）、以及 sstatus 等关键寄存器。随后通过 sret 指令从内核态切换到用户态，CPU 跳转到 trapframe 中设置的 epc 地址，即应用程序的入口点，开始执行用户代码。整个过程依赖于 trapframe 的正确设置，保证了进程能够从内核安全地切换到用户空间，并从应用程序的第一条指令开始运行。

综上，load_icode 的设计实现保证了用户程序能够被正确加载到内存，并通过 trapframe 的精确初始化，使进程能够顺利从内核态切换到用户态，开始执行用户代码。这是用户进程创建和启动的核心环节，也是操作系统实现多进程管理的基础。

---

### 练习2: 父进程复制自己的内存空间给子进程（需要编码）
*创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。请在实验报告中简要说明你的设计实现过程。*
*如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。*

在本实验中，do_fork 函数用于创建子进程，其核心步骤之一是复制父进程的用户内存空间到子进程。具体实现是通过 copy_range 函数完成的。copy_range 会遍历父进程的页表，将每一页的内容复制到新分配的物理页，并建立子进程页表的映射关系。这样可以保证子进程拥有与父进程相同的用户空间内容，实现进程地址空间的独立性。

copy_range 实现思路如下：首先遍历指定的虚拟地址区间，查找父进程的页表项（PTE），如果该页有效，则为子进程分配新物理页，并用 memcpy 将父进程页的内容复制到新页。然后通过 page_insert 将新页映射到子进程的页表中，权限位（perm）也会根据父进程页表项进行设置。这样，子进程获得了与父进程一致的内存内容，但物理页是独立分配的，互不影响。

```c
uintptr_t src_kvaddr = (uintptr_t)page2kva(page);
uintptr_t dst_kvaddr = (uintptr_t)page2kva(npage);
memcpy((void *)dst_kvaddr, (void *)src_kvaddr, PGSIZE);
ret = page_insert(to, npage, start, perm);
```
这四行代码实现了父进程到子进程用户空间的页级内容复制。首先通过 page2kva(page) 和 page2kva(npage) 分别获取父进程和子进程物理页的内核虚拟地址，然后用 memcpy 将父页的内容完整复制到新分配的子页。最后，调用 page_insert 将新页映射到子进程的页表，并设置相应的权限。这样做的好处是保证了子进程获得与父进程一致的内存内容，同时物理页是独立分配的，避免了进程间的内存干扰，为后续的进程隔离和资源管理打下了基础。整个过程简洁高效，充分利用了内核的页管理和映射机制。

Copy on Write（COW）机制设计概要：
- COW 机制的核心思想是：在 fork 时，父子进程共享物理页，只有在某一方试图写入该页时，才进行物理页的复制。具体设计如下：
- fork 时，不直接复制物理页，而是将页表项的写权限去掉，并设置 COW 标志（可用自定义 PTE 标志位）。
父子进程页表都指向同一物理页，且该页的引用计数加一。
当某进程写入该页时，触发页异常（page fault），内核检测到 COW 标志后，为该进程分配新物理页，将原页内容复制过去，更新页表为可写，并清除 COW 标志，原页引用计数减一。
这样只有在实际写入时才分配新页，显著减少 fork 时的物理内存消耗，提高系统效率。

---

### 练习3:阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
*请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？*
*请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）*

fork/exec/wait/exit 的执行流程分析：

1. fork
用户态进程通过系统调用 sys_fork 进入内核，内核在 do_fork（proc.c）中完成子进程的创建。主要步骤包括：分配并初始化 proc_struct（alloc_proc）、分配内核栈（setup_kstack）、复制或共享内存空间（copy_mm，实际复制由 copy_range 完成）、设置 trapframe 和上下文（copy_thread），最后将新进程加入进程链表并唤醒（set_links、wakeup_proc）。fork 的返回值通过 trapframe 传递回用户态，父进程获得子进程 pid，子进程获得 0。

2. exec
用户态进程通过 sys_exec 系统调用进入内核，内核在 do_execve（proc.c）中回收原有内存空间（exit_mmap、put_pgdir），调用 load_icode 加载新的用户程序（解析 ELF，分配内存，设置 trapframe），并更新进程名。exec 的结果通过 trapframe 返回，用户态进程从新程序入口开始执行。

3. wait
用户态进程通过 sys_wait 进入内核，内核在 do_wait（proc.c）中遍历子进程链表，查找处于 ZOMBIE 状态的子进程，回收其资源（unhash_proc、remove_links、put_kstack、kfree），并将退出码返回给用户态。如果没有可回收的子进程，则当前进程进入 SLEEPING 状态，等待唤醒。

4. exit
用户态进程通过 sys_exit 进入内核，内核在 do_exit（proc.c）中释放进程内存空间（exit_mmap、put_pgdir、mm_destroy），设置进程状态为 ZOMBIE，保存退出码，唤醒父进程（wakeup_proc），并调用调度器切换到其他进程（schedule）。资源最终由父进程 wait 时回收。

用户态与内核态的交错执行：
所有上述操作的入口均为用户态系统调用，触发 trap 进入内核态，内核完成实际资源管理和状态变更。内核态通过 trapframe 将结果（如返回值、错误码）写回，trap 返回后用户态进程继续执行。进程调度、状态切换、资源分配与回收均在内核态完成，用户态仅负责发起请求和接收结果。

内核态执行结果返回机制：
内核通过修改 trapframe（如 a0/a1 等寄存器）将系统调用返回值传递给用户态。trap 返回时，CPU 恢复 trapframe 内容，用户态进程从系统调用返回点继续执行，获得内核操作结果。

ucore 用户态进程执行状态生命周期图：
```
+------------------+         fork/execve         +------------------+
|  PROC_UNINIT     |---------------------------> |  PROC_RUNNABLE   |
+------------------+                             +------------------+
         ^                                               |
         |                                               | schedule
         |                                               v
         |                                       +------------------+
         |                                       |  PROC_SLEEPING   |
         |                                       +------------------+
         |                                               ^
         |                                               | wakeup_proc
         |                                               |
         |                                       +------------------+
         |                                       |  PROC_ZOMBIE     |
         |<------------------- do_exit ---------- +------------------+
         |                                               |
         |<------------------- do_wait ------------------+
```

状态变换事件/函数：
- PROC_UNINIT → PROC_RUNNABLE：fork/execve 创建进程
- PROC_RUNNABLE → PROC_SLEEPING：do_wait/do_sleep 等待事件
- PROC_SLEEPING → PROC_RUNNABLE：wakeup_proc 唤醒进程
- PROC_RUNNABLE → PROC_ZOMBIE：do_exit 进程退出
- PROC_ZOMBIE → 资源回收：do_wait 回收资源并删除进程

### 扩展练习 Challenge
#### 实现 Copy on Write （COW）机制


#### 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？


## 知识点总结

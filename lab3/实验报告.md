# 中断与中断处理流程

小组成员：
- 2310648 高景珩
- 2313892 章昊

---

## 实验目的

实验3围绕中断处理机制展开：操作系统作为计算机系统的“总控”，必须随时响应程序异常或外设请求等突发状况；当异常发生时，CPU立即暂停当前任务，由操作系统接管，保存现场、跳转至对应的中断服务例程，处理完毕后再恢复现场，原任务无缝继续执行。通过学习，将掌握RISC-V中断体系与相关寄存器、上下文保存与恢复的完整流程，以及断点中断和时钟中断的最简实现。

---

## 实验内容

### 练习一：完善中断处理 （需要编程）

*请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。*

最后实现的代码如下：
```c
case IRQ_S_TIMER:
    /*(1)设置下次时钟中断- clock_set_next_event()
     *(2)计数器（ticks）加一
     *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
     *(4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
     */
    clock_set_next_event();
    ticks++;
    if (ticks == TICK_NUM) {
        print_ticks();
        print_num++;
        ticks = 0;
    }
    if (print_num == 10) {
        sbi_shutdown();
    }
    break;
```
执行结果如下：
![alt text](image/exe1.png)
在ucore操作系统中，定时器中断的实现是一个关键的功能模块，负责提供系统所需的时间基准和调度支持。整个实现过程可分为初始化、中断触发和中断处理三个主要阶段。

首先，在系统初始化阶段，通过调用clock_init()函数完成定时器的配置。该函数启用supervisor模式下的定时器中断，通过设置sie寄存器的MIP_STIP位允许定时器中断的发生。接着，调用clock_set_next_event()函数设定首次定时器中断的触发时间，该函数通过sbi_set_timer()接口向SBI固件请求设置定时器，设定的时间点为当前时间加上一个固定的时间间隔timebase（100000）。最后，初始化全局变量ticks为0，用于记录定时器中断发生的次数。

定时器中断的处理流程始于硬件层面的中断触发。当到达预设的时间点时，硬件会产生supervisor定时器中断。该中断由RISC-V架构的中断处理机制捕获，并跳转至__alltraps入口点（定义于trapentry.S中）。__alltraps负责保存处理器状态和寄存器上下文到trapframe结构体中，然后调用C语言编写的trap()函数进行进一步处理。

在trap()函数中，根据中断/异常类型将控制权分发给interrupt_handler()。interrupt_handler()通过检查trapframe中的cause字段确定中断类型为IRQ_S_TIMER（supervisor定时器中断），进而执行相应的处理逻辑。

具体的定时器中断处理逻辑实现在LAB3练习1中完成，包括四个步骤：首先调用clock_set_next_event()设置下一次定时器中断；其次将ticks计数器加一；然后判断ticks是否达到TICK_NUM（即100），如果达到则调用print_ticks()输出"100 ticks"信息并将全局变量print_num加一，同时重置ticks为0；最后检查print_num是否达到10，如果是则调用sbi_shutdown()关闭系统。

这种设计形成了一个精确可控的周期性定时器中断机制，每经过固定时间间隔就会产生中断，当累积产生1000次（100次×10轮）定时器中断后自动关闭系统，从而验证了定时器中断功能的正确性和稳定性。

 ### 扩展练习 Challenge1：描述与理解中断流程

 *回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。*

 在ucore操作系统中，中断异常处理流程如下：

1. **中断触发**: 当硬件设备或异常情况产生时（如时钟中断、非法指令、断点等），CPU会暂停当前正在执行的程序。

2. **跳转到中断处理入口**: RISC-V架构会根据stvec寄存器的设置跳转到中断处理入口__alltraps。在ucore中，这个初始化工作是在idt_init()函数中完成的：
   ```c
   void idt_init(void) {
       extern void __alltraps(void);
       write_csr(sscratch, 0);
       write_csr(stvec, &__alltraps);
   }
   ```

3. **保存寄存器状态**: 在__alltraps中，首先执行SAVE_ALL宏来保存所有通用寄存器和中断相关信息到栈上。具体来说：
   - 将当前栈指针保存到sscratch寄存器
   - 分配栈空间（36个寄存器 * REGBYTES）
   - 依次保存各通用寄存器x0-x31
   - 读取并保存特殊寄存器：sstatus、sepc、stval、scause

4. **传递参数并调用C函数**: 通过`move a0, sp`指令将当前栈指针（指向保存的trapframe结构）作为参数传给C语言编写的trap()函数。

5. **中断分发处理**: trap()函数调用trap_dispatch()，根据中断类型将控制权交给interrupt_handler()或exception_handler()。

6. **具体处理**: 根据中断类型进行具体处理，例如时钟中断会增加ticks计数器，打印信息等。

7. **恢复现场并返回**: 处理完成后，返回到__trapret，执行RESTORE_ALL宏恢复寄存器状态，最后使用`sret`指令从中断返回。

**关于mov a0, sp的目的：**

`move a0, sp`指令的作用是将当前的栈指针（指向刚刚保存的trapframe结构）作为参数传递给trap()函数。因为在RISC-V的调用约定中，第一个参数通过a0寄存器传递。这样trap()函数就能访问到完整的trapframe结构，包含所有被中断时刻的寄存器状态和中断相关信息。

**SAVE_ALL中寄存器保存在栈中的位置是如何确定的：**

寄存器在栈中的位置是由trapframe结构体的布局决定的。在SAVE_ALL宏中，寄存器按照固定的偏移量存储：

- 通用寄存器x0-x31按顺序存储，每个寄存器占REGBYTES字节
- 特殊寄存器存储在偏移量32-35的位置：
  - 32 * REGBYTES: status寄存器(sstatus)
  - 33 * REGBYTES: epc寄存器(sepc)
  - 34 * REGBYTES: badvaddr寄存器(stval)
  - 35 * REGBYTES: cause寄存器(scause)

这个布局与C语言中trapframe结构体的定义完全一致，使得后续可以通过指针访问这些数据。

**对于任何中断，__alltraps中都需要保存所有寄存器吗：**

是，对于任何中断，__alltraps中都需要保存所有寄存器。理由如下：

1. **保证中断处理的透明性**: 保存所有寄存器确保中断处理完成后能够完全恢复到中断前的状态，使得被中断的程序能够继续正确执行。

2. **统一处理流程**: 不同类型的中断可能需要用到不同的寄存器值进行处理，事先保存所有寄存器可以让中断处理程序灵活地访问任何需要的信息。

3. **嵌套中断处理**: 如果在中断处理过程中又发生了新的中断，保存完整的寄存器状态可以确保中断处理的正确嵌套。

4. **调试和诊断**: 完整的寄存器状态对调试和异常诊断非常有用，可以帮助开发者分析中断发生时的程序状态。

虽然保存所有寄存器会带来一定的性能开销，但这是确保系统稳定性和可预测性的必要代价。
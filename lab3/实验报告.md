# 中断与中断处理流程

小组成员：
- 2310648 高景珩
- 2313892 章昊

---

## 实验目的

实验3围绕中断处理机制展开：操作系统作为计算机系统的“总控”，必须随时响应程序异常或外设请求等突发状况；当异常发生时，CPU立即暂停当前任务，由操作系统接管，保存现场、跳转至对应的中断服务例程，处理完毕后再恢复现场，原任务无缝继续执行。通过学习，将掌握RISC-V中断体系与相关寄存器、上下文保存与恢复的完整流程，以及断点中断和时钟中断的最简实现。

---

## 实验内容

### 练习一：完善中断处理 （需要编程）

*请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。*

最后实现的代码如下：
```c
case IRQ_S_TIMER:
    /*(1)设置下次时钟中断- clock_set_next_event()
     *(2)计数器（ticks）加一
     *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
     *(4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
     */
    clock_set_next_event();
    ticks++;
    if (ticks == TICK_NUM) {
        print_ticks();
        print_num++;
        ticks = 0;
    }
    if (print_num == 10) {
        sbi_shutdown();
    }
    break;
```
执行结果如下：
![alt text](image/exe1.png)
在ucore操作系统中，定时器中断的实现是一个关键的功能模块，负责提供系统所需的时间基准和调度支持。整个实现过程可分为初始化、中断触发和中断处理三个主要阶段。

首先，在系统初始化阶段，通过调用clock_init()函数完成定时器的配置。该函数启用supervisor模式下的定时器中断，通过设置sie寄存器的MIP_STIP位允许定时器中断的发生。接着，调用clock_set_next_event()函数设定首次定时器中断的触发时间，该函数通过sbi_set_timer()接口向SBI固件请求设置定时器，设定的时间点为当前时间加上一个固定的时间间隔timebase（100000）。最后，初始化全局变量ticks为0，用于记录定时器中断发生的次数。

定时器中断的处理流程始于硬件层面的中断触发。当到达预设的时间点时，硬件会产生supervisor定时器中断。该中断由RISC-V架构的中断处理机制捕获，并跳转至__alltraps入口点（定义于trapentry.S中）。__alltraps负责保存处理器状态和寄存器上下文到trapframe结构体中，然后调用C语言编写的trap()函数进行进一步处理。

在trap()函数中，根据中断/异常类型将控制权分发给interrupt_handler()。interrupt_handler()通过检查trapframe中的cause字段确定中断类型为IRQ_S_TIMER（supervisor定时器中断），进而执行相应的处理逻辑。

具体的定时器中断处理逻辑实现在LAB3练习1中完成，包括四个步骤：首先调用clock_set_next_event()设置下一次定时器中断；其次将ticks计数器加一；然后判断ticks是否达到TICK_NUM（即100），如果达到则调用print_ticks()输出"100 ticks"信息并将全局变量print_num加一，同时重置ticks为0；最后检查print_num是否达到10，如果是则调用sbi_shutdown()关闭系统。

这种设计形成了一个精确可控的周期性定时器中断机制，每经过固定时间间隔就会产生中断，当累积产生1000次（100次×10轮）定时器中断后自动关闭系统，从而验证了定时器中断功能的正确性和稳定性。

 ### 扩展练习 Challenge1：描述与理解中断流程

 *回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。*

 在ucore操作系统中，中断异常处理流程如下：

1. **中断触发**: 当硬件设备或异常情况产生时（如时钟中断、非法指令、断点等），CPU会暂停当前正在执行的程序。

2. **跳转到中断处理入口**: RISC-V架构会根据stvec寄存器的设置跳转到中断处理入口__alltraps。在ucore中，这个初始化工作是在idt_init()函数中完成的：
   ```c
   void idt_init(void) {
       extern void __alltraps(void);
       write_csr(sscratch, 0);
       write_csr(stvec, &__alltraps);
   }
   ```

3. **保存寄存器状态**: 在__alltraps中，首先执行SAVE_ALL宏来保存所有通用寄存器和中断相关信息到栈上。具体来说：
   - 将当前栈指针保存到sscratch寄存器
   - 分配栈空间（36个寄存器 * REGBYTES）
   - 依次保存各通用寄存器x0-x31
   - 读取并保存特殊寄存器：sstatus、sepc、stval、scause

4. **传递参数并调用C函数**: 通过`move a0, sp`指令将当前栈指针（指向保存的trapframe结构）作为参数传给C语言编写的trap()函数。

5. **中断分发处理**: trap()函数调用trap_dispatch()，根据中断类型将控制权交给interrupt_handler()或exception_handler()。

6. **具体处理**: 根据中断类型进行具体处理，例如时钟中断会增加ticks计数器，打印信息等。

7. **恢复现场并返回**: 处理完成后，返回到__trapret，执行RESTORE_ALL宏恢复寄存器状态，最后使用`sret`指令从中断返回。

**关于mov a0, sp的目的：**

`move a0, sp`指令的作用是将当前的栈指针（指向刚刚保存的trapframe结构）作为参数传递给trap()函数。因为在RISC-V的调用约定中，第一个参数通过a0寄存器传递。这样trap()函数就能访问到完整的trapframe结构，包含所有被中断时刻的寄存器状态和中断相关信息。

**SAVE_ALL中寄存器保存在栈中的位置是如何确定的：**

寄存器在栈中的位置是由trapframe结构体的布局决定的。在SAVE_ALL宏中，寄存器按照固定的偏移量存储：

- 通用寄存器x0-x31按顺序存储，每个寄存器占REGBYTES字节
- 特殊寄存器存储在偏移量32-35的位置：
  - 32 * REGBYTES: status寄存器(sstatus)
  - 33 * REGBYTES: epc寄存器(sepc)
  - 34 * REGBYTES: badvaddr寄存器(stval)
  - 35 * REGBYTES: cause寄存器(scause)

这个布局与C语言中trapframe结构体的定义完全一致，使得后续可以通过指针访问这些数据。

**对于任何中断，__alltraps中都需要保存所有寄存器吗：**

是，对于任何中断，__alltraps中都需要保存所有寄存器。理由如下：

1. **保证中断处理的透明性**: 保存所有寄存器确保中断处理完成后能够完全恢复到中断前的状态，使得被中断的程序能够继续正确执行。

2. **统一处理流程**: 不同类型的中断可能需要用到不同的寄存器值进行处理，事先保存所有寄存器可以让中断处理程序灵活地访问任何需要的信息。

3. **嵌套中断处理**: 如果在中断处理过程中又发生了新的中断，保存完整的寄存器状态可以确保中断处理的正确嵌套。

4. **调试和诊断**: 完整的寄存器状态对调试和异常诊断非常有用，可以帮助开发者分析中断发生时的程序状态。

虽然保存所有寄存器会带来一定的性能开销，但这是确保系统稳定性和可预测性的必要代价。

### 扩展练习 Challenge2：理解上下文切换机制

*在`trapentry.S`中汇编代码 `csrw sscratch, sp`；`csrrw s0, sscratch, x0`实现了什么操作，目的是什么？save all里面保存了`stval scause`这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？*

1. `csrw sscratch, sp`
   - 操作：将当前栈指针的值写入到`sscratch`这个CSR寄存器中。
   - 目的：在进入异常处理程序时，`sp`原先指向被中断代码的栈，由于异常处理程序需要保存寄存器信息到内存中，`sp`将指向保存`trapframe`结构体的地址，故原先的`sp`需要临时保存到`sscratch`中，保证可以恢复到中断前的栈指针。`sscratch` 就是一个专门为这种临时保存设计的寄存器。
2. `csrrw s0, sscratch, x0`
   - 操作：这是一个原子读写指令。它做了两件事：一是将`sscratch`的值（即原`sp`的值）存入`s0`寄存器，二是将`x0`寄存器（即0值）写入`sscratch`寄存器。
   - 目的：将之前保存在 `sscratch` 中的原始栈指针取回到一个通用寄存器 `s0` 中，以便后续可以把它和其他寄存器一起存入 `trapframe` 结构体里：在`trapentry.S`中可以观察到，`SAVE_ALL`在一开始并未将`x2(sp)`存入栈中，而是在`ssratch`的值写入`s0`后，通过`STORE s0, 2*REGBYTES(sp)`存入栈的。另一方面，将 `sscratch` 设置为0，这是一个重要的安全机制：如果此时（在内核异常处理期间）发生另一次异常（即嵌套异常），异常入口代码可以通过检查 `sscratch` 的值来判断异常是来自用户态（`sscratch` 非0）还是内核态（`sscratch` 为0）。在内核态发生异常通常是严重错误，需要特殊处理（比如 panic）。

`SAVE_ALL`中保存了`stval, scause`这两个CSR寄存器，它们由硬件自动设置，保存是为了让软件能通过异常处理函数`trap_dispatch`读取到异常发生的原因、与异常相关的附加信息，从而让软件知道发生了什么类型的异常，并进行相应的处理。

`RESTORE_ALL`中不恢复这两者，是因为这两个寄存器的值只在异常发生的那一刻有意义。在异常处理返回后，因为程序已经正常执行，不再处于异常状态，恢复它没有任何作用，也就不需要恢复了。

与这两者不同，`sepc` 保存了异常发生时指令的地址，决定了异常处理结束后程序从哪里继续执行。`sstatus` 保存了异常发生前的CPU状态（如中断使能位、先前权限级别等）。因此，这两个CSR寄存器有必要在异常处理完成后恢复，从而让CPU回到正常状态。

### 扩展练习 Challenge3：完善异常中断

*编程完善在触发一条非法指令异常和断点异常，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。*

#### 实现思路

由于uCore中已经实现了`exception_handler`函数的框架，我们只需在switch块下补充`case CAUSE_ILLEGAL_INSTRUCTION:`和`case CAUSE_BREAKPOINT:`两种情况的处理方式。

处理这两种异常的核心步骤是相似的：

- 识别异常：通过 `switch (tf->cause)` 语句，进入对应的异常处理分支。
- 报告异常：使用 `cprintf` 函数打印出异常的类型和发生异常的指令地址。发生异常的指令地址存储在 `trapframe` 的 `epc` 成员中。
- 跳过异常指令：修改 `tf->epc` 的值，使其指向下一条指令。这是至关重要的一步，否则当从异常处理返回后，CPU会再次执行导致异常的指令，从而陷入死循环。

考虑到 RISC-V 架构支持标准的 4 字节指令和可选的 2 字节压缩指令（如实验一中分析过的`j`指令），在更新 `epc` 时必须能够正确判断指令长度。我们通过检查指令编码的最低两位来实现这一点：

- 如果指令编码的最低两位是 11，则为 4 字节指令。
- 否则（为 00, 01, 10），则为 2 字节指令。

对于非法指令异常，`tf->badvaddr` 中保存了指令本身的二进制编码。因此，我们可以通过 `(tf->badvaddr & 0x3) != 0x3` 来判断指令是否为 2 字节，进而采取不同的更新方式。

最终的实现代码如下：
```c
void exception_handler(struct trapframe *tf) {
    switch (tf->cause) {
    // ......
        case CAUSE_ILLEGAL_INSTRUCTION:
             // 非法指令异常处理
            cprintf("Exception type: Illegal instruction\n");
            cprintf("Illegal instruction caught at 0x%08x\n", tf->epc);
            // 判断指令末两位是否为11，如果是则为4字节指令，否则为2字节指令
            tf->epc += ((tf->badvaddr & 0x3) != 0x3) ? 2 : 4;
            break;
        case CAUSE_BREAKPOINT:
            //断点异常处理
            cprintf("Exception type: breakpoint\n");
            cprintf("ebreak caught at 0x%08x\n", tf->epc);
            tf->epc += ((tf->badvaddr & 0x3) != 0x3) ? 2 : 4;
            break;
    // ......
    }
}
```

#### 结果验证

##### 测试1：断点异常

通过在`kern_init`中插入`asm volatile("ebreak");`来触发断点异常。`make qemu` 后的输出如下：
```
Exception type: breakpoint
ebreak caught at 0xc020009c
```

分析：程序成功捕获了 `ebreak` 指令引发的断点异常，打印了正确的异常类型和指令地址 `0xc020009c`。随后 `epc` 被更新，跳过了 `ebreak` 指令，内核继续执行后续的 `while(1)` 循环，表现符合预期。

##### 测试2：非法指令异常

通过 `asm volatile(".word 0x00000000");` 在`kern_init`中插入一条全零的指令，这在 RISC-V 中是一条非法指令。make qemu 后的输出如下：

```
Exception type: Illegal instruction
Illegal instruction caught at 0xc020009c
Exception type: Illegal instruction
Illegal instruction caught at 0xc020009e
```

分析：这里出现了两次连续的非法指令异常，需要特别解释：

第一次异常：CPU 在地址 `0xc020009c` 处取指，取到了我们插入的 4 字节非法指令 `0x00000000`。我们的异常处理程序捕获了它，打印了第一条信息。根据指令编码 `0x00000000` 的最低两位是 00，我们的 `epc` 更新逻辑 `((tf->badvaddr & 0x3) != 0x3) ? 2 : 4` 判断其为 2 字节指令，因此将 `epc` 更新为 `0xc020009c + 2 = 0xc020009e`。

第二次异常：当从第一次异常处理返回后，程序从新的 `epc` 地址 `0xc020009e` 处继续执行。这个地址指向了我们插入的 4 字节非法指令的后半部分（即 `0x0000`）。CPU 将其作为一条新的 2 字节指令进行译码，但它同样是非法的。因此，系统再次触发了非法指令异常，打印了第二条信息。随后 `epc` 再次加 2，最终跳过了整个 4 字节的非法指令区域。

这个结果虽然看起来有些意外，但它恰好证明了我们根据指令编码动态调整 `epc` 步长的处理逻辑是正确且有效的。如果不考虑指令长度直接进行`tf->epc += 4`，那么就很可能会导致对齐错误从而引发一系列非法指令异常，进而陷入死循环。

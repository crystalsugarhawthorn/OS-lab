# 伙伴系统（Buddy System）物理内存管理器设计文档

## 1. 设计思路

### 1.1. 核心思想

伙伴系统（Buddy System）是一种经典的物理内存分配算法，其核心在于高效地管理和减少内存碎片，特别是外部碎片。 它的主要思想如下：

*   **内存分块**：将整个物理内存空间划分为大小为 2 的幂次方（$2^0$, $2^1$, $2^2$, ...）的内存块。每个块的大小称为“阶”（Order），一个 order 为 `n` 的块包含 $2^n$ 个物理页。
*   **伙伴关系**：任何一个内存块都可以被一分为二，分裂后的两个子块大小相等，且互为“伙伴”。 这两个伙伴块的地址存在特定的数学关系（通常是异或关系），使得它们可以高效地找到对方。
*   **分裂与合并**：
    *   **分裂（Splitting）**：当需要分配一块内存时，算法会寻找能够满足需求的最小的空闲块。如果找到的空闲块过大，它将被反复地一分为二，直到产生一个大小合适的块。 多余的伙伴块会被加入相应阶的空闲链表中。
    *   **合并（Coalescing）**：当一块内存被释放时，算法会检查其伙伴块是否也处于空闲状态。 如果是，则将这两个伙伴块合并成一个更大的块。这个合并过程会递归进行，直到无法再合并为止，从而尽可能地恢复出大的连续内存区域。

### 1.2. 本实现的设计目标

本设计旨在实现一个基于页帧（Page Frame）的伙伴系统物理内存管理器（PMM）。它与上层 PMM 框架解耦，通过 `pmm_manager` 接口提供服务。

*   **数据结构**：利用一个全局数组 `free_area_t free_area[MAX_ORDER + 1]` 来管理所有空闲块。数组的每个元素代表一个阶（order），包含一个双向链表 `free_list` 用于链接该阶的所有空闲块，以及一个计数器 `nr_free`。
*   **元数据存储**：为了节省空间，块的元数据（主要是它的阶 `order`）被巧妙地存储在块的第一个 `Page` 结构体的 `property` 字段中。同时，通过 `Page` 结构中的 `flags` 字段（`PG_property` 位）来标识一个 `Page` 是否为空闲块的首页。
*   **地址与对齐**：所有地址计算和伙伴查找都基于页帧号（PPN），这简化了对齐检查和伙伴地址的计算，因为它们可以高效地通过位运算完成。

## 2. 核心数据结构与约定

### `free_area_t`
这是管理每一阶（order）空闲块的核心结构。

```c
static free_area_t free_area[MAX_ORDER + 1];
```
*   `free_list`: 一个双向链表头，链接了所有属于该阶的空闲块。
*   `nr_free`: 记录该阶当前有多少个空闲块。

### `struct Page` 的扩展用途
本实现复用了 `Page` 结构体来存储伙伴系统的元数据，避免了额外的内存开销。

*   `page.property`:
    *   如果一个 `Page` 是一个空闲块的 **首页**，则该字段存储这个块的 **阶（order）**。
    *   如果是一个已分配块的首页，它同样存储该块的阶，用于释放时计算大小。
    *   对于块内的其他页，该字段为 0。
*   `page.flags`:
    *   `PG_property` 标志位：当该位置位时，表示这个 `Page` 是一个 **空闲块的首页**。这个标志是判断一个块能否被合并的关键。
*   `page.page_link`: 用于将空闲块的首页链接到 `free_area` 对应阶的 `free_list` 中。

### 关键宏定义
为了代码的可读性和便利性，定义了以下宏：

```c
#define MAX_ORDER   16                  // 系统支持的最大阶
#define free_list(order)   (free_area[(order)].free_list) // 访问指定阶的空闲链表
#define nr_free(order)     (free_area[(order)].nr_free)   // 访问指定阶的空闲块计数
```

## 3. 核心代码函数分析

### `buddy_system_init_memmap(struct Page *base, size_t n)` - 初始化内存区域
此函数负责将一段连续的物理内存区域纳入伙伴系统管理。这是一个自顶向下的分解过程。

**实现逻辑**:
1.  **初始化页面状态**：遍历 `[base, base+n)` 范围内的所有 `Page` 结构，清除它们的 `flags` 和 `property`，并将引用计数设为 0。
2.  **自顶向下分解**：
    *   从当前内存区域的起始地址 `addr` 和剩余页数 `remaining` 开始循环。
    *   在每次循环中，首先尝试找到能容纳于 `remaining` 页中的最大阶 `order`（从 `MAX_ORDER` 开始向下找）。
    *   接着，检查当前 `addr` 是否与这个 `order` 所需的对齐方式（`addr` 必须是 `2^order` 的倍数）相匹配。如果不匹配，则继续降低 `order` 直到满足对齐要求。
    *   确定了合适的 `order` 和 `addr` 后，一个符合伙伴系统要求的块就被“划分”出来了。
    *   **设置元数据**：将块的首页的 `property` 设为 `order`，并设置 `PG_property` 标志位。
    *   **加入空闲链表**：将这个块添加到 `free_list(order)` 的尾部，并增加 `nr_free(order)` 的计数。
    *   更新 `addr` 和 `remaining`，继续处理下一段内存，直到所有页都被纳入管理。

```c
// 关键对齐逻辑
while (order > 0 && (addr & (order2pages(order) - 1)) != 0) {
    order--;
}
```
这个对齐检查是伙伴系统的核心约束，它确保了伙伴地址计算的正确性。

### `buddy_system_alloc_pages(size_t n)` - 分配页
此函数负责从伙伴系统中分配 `n` 个连续页。

**实现逻辑**:
1.  **计算所需阶**：根据请求的页数 `n`，计算出能满足该需求的最小阶 `order`（即 `2^order >= n`）。
2.  **查找空闲块**：从 `order` 阶开始，向上（`current_order`）查找第一个非空的空闲链表 `free_list`。
3.  **获取并分裂**：
    *   如果找不到任何空闲块 (`current_order > MAX_ORDER`)，则分配失败。
    *   否则，从 `free_list(current_order)` 中取出一个空闲块（通常是第一个）。
    *   如果取出的块 (`current_order`) 大于所需的块 (`order`)，则进行 **循环分裂**：
        *   将 `current_order` 减一。
        *   计算出伙伴块（右半部分）的地址。
        *   将伙伴块标记为一个新的、更小的空闲块（设置 `property` 和 `PG_property`），并将其加入 `free_list(current_order)`。
        *   原块指针保持不变（指向左半部分），继续分裂，直到 `current_order` 等于 `order`。
4.  **标记和返回**：
    *   最终得到的 `order` 阶块的 `PG_property` 标志被清除，表示它不再是空闲块。
    *   其 `property` 字段仍保留 `order` 值，以便释放时使用。
    *   将该块内所有页的引用计数设置为 1。
    *   返回块的首页指针。

### `buddy_system_free_pages(struct Page *base, size_t n)` - 释放页
此函数负责释放一个之前分配的块，并智能地尝试与伙伴块进行合并。

**实现逻辑**:
1.  **计算阶**：根据 `n` 计算出被释放块的阶 `order`。
2.  **清理状态**：重置块内所有页的 `flags`、`property` 和引用计数。
3.  **循环合并**：
    *   获取当前块的页帧号 `ppn`。
    *   **计算伙伴地址**：通过 `buddy_ppn = ppn ^ order2pages(order)` 这个位运算高效地找到伙伴块的地址。这是伙伴算法的精髓。
    *   **检查合并条件**：伙伴块必须是空闲的（`PageProperty` 为真）且阶数必须与当前块相同（`buddy->property == order`）。
    *   如果满足条件：
        *   将伙伴块从其空闲链表中移除。
        *   根据地址高低确定哪个块成为新合并块的块首（地址较低者）。非块首的那个页需要清除其 `property` 和 `PG_property`。
        *   将 `order` 加一，然后带着这个新合并的、更大的块进入下一轮循环，尝试继续合并。
    *   如果不满足条件，则合并过程终止。
4.  **加入空闲链表**：
    *   合并结束后，将最终形成的块（可能是原始块，也可能是合并后的大块）标记为空闲块（设置 `property` 和 `PG_property`）。
    *   将其添加到对应阶的 `free_list` 中。

## 4. 测试角度

`buddy_system_check()` 函数提供了一个全面的内部测试套件，覆盖了伙伴系统的主要功能点和边界情况。测试角度可以归纳为以下几类：

1.  **基本功能测试**:
    *   **分配与释放**：分配不同大小（1, 2, 4 页）的块，然后全部释放，检查空闲页总数是否恢复到初始状态。这验证了最基本的分配和回收逻辑。

2.  **分裂机制测试**:
    *   **场景**: 先分配一个较大的块（如 8 页），然后再分配几个小块（如 1 页）。
    *   **目的**: 验证当没有恰好大小的块时，分配器是否能正确地将大块分裂成小块来满足请求。释放后也应能正确恢复。

3.  **合并机制测试**:
    *   **场景**: 分配两个大小相同且物理上相邻（互为伙伴）的块，然后依次释放它们。
    *   **目的**: 验证当一个块被释放时，系统是否能正确检测到其伙伴也是空闲的，并自动将它们合并成一个更大的块。
    *   **乱序释放**: 分配多个块，然后以随机顺序释放它们。这用于测试合并逻辑在非顺序释放场景下的鲁棒性。

4.  **压力与鲁棒性测试**:
    *   **耗尽测试**: 循环分配最小单位（1 页）的块，直到内存耗尽 (`alloc` 返回 `NULL`)。
    *   **目的**: 测试系统在内存压力下的行为，并验证在全部释放后，内存是否能完全恢复，无泄漏。

5.  **边界条件测试**:
    *   **超大分配**: 请求一个大于 `MAX_ORDER` 所能提供的最大块的内存。
    *   **目的**: 预期分配应失败并返回 `NULL`，验证系统的边界检查。
    *   **零页分配**：虽然代码中断言 `n > 0`，但在完整的测试中也应考虑请求 0 页的场景。

这些测试覆盖了从简单到复杂的各种场景，确保了伙伴系统在分裂、合并、顺序和乱序操作以及资源耗尽等情况下的正确性和稳定性。
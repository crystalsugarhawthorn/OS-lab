# 设计文档：两种伙伴系统（Buddy System）物理内存管理器

## 1. 概述

### 1.1 背景
物理内存管理（Physical Memory Management, PMM）是操作系统的核心组件之一，负责高效地分配和回收物理内存页。伙伴系统（Buddy System）是一种经典的内存分配算法，它通过将内存划分为 2 的幂次大小的块来管理内存，能有效减少外部碎片并实现快速的块合并。

### 1.2 目的
本文档旨在详细介绍两种伙伴系统物理内存管理器的实现方式：
1.  **基于数组的实现 (`buddy_system_array_pmm.c`)**：使用一个数组来模拟完全二叉树，管理内存块的状态。
2.  **基于链表的实现 (`buddy_system_list_pmm.c`)**：使用一个链表数组，每个链表管理特定大小的空闲内存块。

文档将深入分析两种实现的核心思想、数据结构、关键函数和优缺点，为理解和选择合适的内存管理方案提供依据。

## 2. 伙伴系统核心概念

伙伴系统将整个内存空间看作一个大的块，其大小为 2 的 `k` 次幂。当需要分配内存时，算法会执行以下操作：
*   **查找**：寻找大小合适且最接近请求大小的空闲块。
*   **分裂**：如果找到的块过大，就将其递归地对半分裂，直到产生大小合适的块。分裂出的两个块互为“伙伴”。
*   **合并**：当一个内存块被释放时，算法会检查其伙伴块是否也为空闲状态。如果是，则将两者合并成一个更大的块，并递归地尝试向上合并。

这种机制使得内存分配和回收非常高效，特别是地址计算可以通过位运算快速完成。

---

## 3. 实现一：基于数组的伙伴系统 (`buddy_system_array_pmm.c`)

### 3.1 核心思想

该实现通过一个**数组 `node_state[]` 来模拟一棵完全二叉树**，从而管理物理内存。

*   **树的结构**：整片待管理的物理内存被视为树的根节点。每个节点代表一个内存块。一个非叶子节点分裂后，其代表的内存块被分为两个大小相等的子块，分别由其左右子节点表示。
*   **节点与数组索引**：树的节点与数组索引一一对应。根节点索引为 1，节点 `i` 的左子节点为 `2*i`，右子节点为 `2*i+1`。 这种映射关系使得父子、兄弟节点的查找非常高效。
*   **状态管理**：`node_state` 数组记录每个节点（内存块）的状态，以此来跟踪内存的分配、空闲和分裂情况。

### 3.2 核心数据结构与约定

*   `static unsigned char node_state[MAX_TREE_NODES + 1]`
    *   这是最核心的数据结构，一个字节数组，用于存储完全二叉树中每个节点的状态。
    *   **约定**：
        *   `0 (ALLOCATED)`：已分配。表示该节点及其所有子节点代表的内存块都已被分配。
        *   `1 (FREE)`：空闲。表示该节点及其所有子节点代表的内存块完全空闲，可以作为一个整体被分配。
        *   `2 (SPLIT)`：已分裂。表示该节点代表的内存块已被分裂成两半，其状态由其两个子节点决定。

*   `static int actual_order`
    *   表示伙伴系统管理的内存区域实际对应的阶数，即管理的内存大小为 `2^actual_order` 个页。它由总页数向下取整到最近的2的幂次得出。

### 3.3 核心代码函数分析

#### `buddy_system_array_alloc_pages(size_t n)` - 分配页面
1.  **计算阶数**：将请求的页数 `n` 向上取整到最接近的 2 的幂（例如，请求 5 页，实际需要一个大小为 8 页的块），并计算出对应的阶 `k`。
2.  **确定目标深度**：根据 `actual_order` 和 `k`，计算出需要在树的哪一层（`target_depth = actual_order - k`）查找空闲块。
3.  **查找空闲节点** (`find_free_node`):
    *   从根节点（索引 1）开始递归向下查找。
    *   如果遇到 `ALLOCATED` 节点，则其子树都不可用，剪枝返回。
    *   如果遇到 `FREE` 节点但尚未达到目标深度，则执行**懒惰分裂**：将其状态改为 `SPLIT`，并将其两个子节点标记为 `FREE`，然后继续向下递归。
    *   如果在 `target_depth` 找到 `FREE` 节点，返回其索引。
4.  **标记和更新**：
    *   找到节点后，调用 `set_subtree_state` 将其及其所有子节点标记为 `ALLOCATED`。
    *   调用 `update_ancestors_after_alloc` 从该节点向上回溯至根，更新所有祖先节点的状态。如果一个节点的两个子节点都为 `ALLOCATED`，那么该节点也变为 `ALLOCATED`。
5.  **计算地址**：通过 `node_start_page` 计算节点索引对应的物理页起始地址并返回。

#### `buddy_system_array_free_pages(struct Page *base, size_t n)` - 释放页面
1.  **定位节点**：根据要释放的内存块的基地址 `base` 和大小 `n`，反向计算出它在完全二叉树中对应的节点索引 `node_idx`。
    *   这需要计算块的阶 `k`、目标深度 `target_depth`，以及块在 `target_depth` 这一层的偏移量。
2.  **标记为空闲**：调用 `set_subtree_state` 将 `node_idx` 及其整个子树标记为 `FREE`。
3.  **合并与更新** (`update_ancestors_after_free`):
    *   这是实现伙伴系统自动合并的关键。
    *   从 `node_idx` 的父节点开始，向上回溯至根。
    *   在每一层，检查其左右子节点（即一对伙伴）的状态。如果两个子节点**都**是 `FREE`，则将父节点的状态也设置为 `FREE`，相当于完成了一次合并。
    *   如果子节点状态不一致，则父节点状态为 `SPLIT`。

### 3.4 优缺点

*   **优点**：
    *   **快速定位**：通过数组索引进行位运算（如 `i<<1`, `i>>1`），可以极快地找到父、子和伙伴节点，无需指针遍历。
    *   **结构简单**：逻辑清晰，所有状态都集中在一个数组中管理，易于调试和理解。
*   **缺点**：
    *   **空间开销大**：需要预先分配一个能容纳 `MAX_ORDER` 阶完全二叉树所有节点的数组，即使实际管理的内存很小，这个数组的大小也是固定的，可能造成空间浪费。
    *   **灵活性差**：`MAX_ORDER` 是编译时固定的，不易扩展。

---

## 4. 实现二：基于链表的伙伴系统 (`buddy_system_list_pmm.c`)

### 4.1 核心思想

该实现为**每一种大小（阶）的空闲内存块维护一个独立的双向链表**。

*   **分阶管理**：使用一个 `free_area_t` 数组，数组的每个元素包含一个链表头和该阶空闲块的数量。`free_area[i]` 管理所有大小为 `2^i` 页的空闲块。
*   **按需查找**：分配内存时，直接去所需阶数的链表中查找。如果找不到，则去更大一阶的链表中取一个块并进行分裂。
*   **元数据存储**：内存块的元数据（如阶数）直接存储在块的首页 `struct Page` 的 `property` 字段中。

### 4.2 核心数据结构与约定

*   `static free_area_t free_area[MAX_ORDER + 1]`
    *   管理所有空闲块的核心数据结构。`free_area_t` 结构体包含：
        *   `list_entry_t free_list`：双向链表的头节点。
        *   `unsigned int nr_free`：该阶空闲块的数量。

*   `struct Page` 的字段约定
    *   `page.property`：当一个块是空闲块时，其**首页**的 `property` 字段存储该块的**阶（order）**。块内其他页的 `property` 为 0。
    *   `page.flags` 中的 `PG_property` 位：如果该位置位，表示这个 `Page` 结构体是一个空闲块的首页。
    *   `page.page_link`：用于将空闲块的首页连接到 `free_area` 的链表中。

### 4.3 核心代码函数分析

#### `buddy_system_list_alloc_pages(size_t n)` - 分配页面
1.  **计算阶数**：同样地，将 `n` 向上取整到 2 的幂，得到所需的阶 `order`。
2.  **查找空闲链表**：从 `order` 阶开始，向上遍历 `free_area` 数组，找到第一个**非空**的空闲链表（`current_order`）。
3.  **获取并分裂**：
    *   从 `free_area[current_order]` 的链表中取出一个空闲块。
    *   如果 `current_order > order`，则进行循环分裂：
        *   将当前块对半切，计算出伙伴块的地址。
        *   将伙伴块（后半部分）作为一个新的、阶数为 `current_order - 1` 的空闲块，插入到 `free_area[current_order - 1]` 的链表中。
        *   前半部分继续参与下一轮分裂，直到阶数降为 `order`。
4.  **返回块**：返回最终得到的 `order` 阶的块，并清除其 `PG_property` 标志，表示它已被分配。

#### `buddy_system_list_free_pages(struct Page *base, size_t n)` - 释放页面
1.  **计算阶数**：根据 `n` 计算出要释放的块的阶 `order`。
2.  **循环合并**：
    *   这是此实现的核心。通过一个 `while` 循环持续尝试合并。
    *   **计算伙伴地址**：使用异或运算 `ppn ^ order2pages(order)` 快速计算出当前块的伙伴块的物理页号（PPN）。这是伙伴系统的一个经典技巧。
    *   **检查伙伴状态**：检查伙伴块是否可以合并。条件是：伙伴块必须是空闲的（通过 `PageProperty` 标志判断），且其阶数必须与当前块相同（`buddy->property == order`）。
    *   **执行合并**：如果可以合并，就将伙伴块从它的空闲链表中移除，然后将当前块的基地址更新为两个块中地址较小的那一个，并将 `order` 加一，进入下一轮循环，尝试与新的、更大的伙伴块合并。
3.  **加入链表**：当循环结束（无法再合并）时，将最终形成的大块设置好 `property` 和 `PG_property` 标志，并将其添加到对应阶的空闲链表中。

### 4.4 优缺点

*   **优点**：
    *   **空间效率高**：只为空闲块存储元数据（链表指针），没有为所有可能存在的块预留空间。
    *   **灵活性好**：管理的数据结构（链表）是动态的，更容易适应不同的内存布局和大小。
*   **缺点**：
    *   **操作相对复杂**：分配和释放涉及较多的链表操作（删除、插入），以及对 `Page` 结构体的元数据进行读写。
    *   **内存访问局部性差**：链表节点在物理内存中可能是分散的，遍历链表时缓存性能可能不如访问连续的数组。

---

## 5. 两种实现的对比总结

| 特性 | 基于数组的实现 (`buddy_system_array_pmm.c`) | 基于链表的实现 (`buddy_system_list_pmm.c`) |
| :--- | :--- | :--- |
| **核心数据结构** | 状态数组 `node_state[]` 模拟完全二叉树 | 空闲链表数组 `free_area[]` |
| **元数据存储** | 集中存储在全局 `node_state` 数组中 | 分散存储在每个空闲块首页的 `Page` 结构体中 |
| **伙伴查找** | 通过数组索引位运算（`idx >> 1`, `idx ^ 1`） | 通过块地址和大小进行异或运算 (`ppn ^ size`) |
| **内存分配** | 递归查找和分裂树节点 | 查找非空链表并循环分裂块 |
| **内存合并** | 递归更新祖先节点状态 | 循环查找并合并伙伴块，更新链表 |
| **空间开销** | **高**。固定大小的数组，与 `MAX_ORDER` 相关 | **低**。开销与当前空闲块数量成正比 |
| **性能特点** | 节点定位极快，但可能受限于数组大小 | 链表操作开销略高，但内存占用更优 |
| **实现复杂度** | 逻辑相对直观，索引计算是关键 | 涉及指针操作和元数据管理，细节更复杂 |

## 6. 结论

两种伙伴系统的实现都有效地解决了物理内存管理中的碎片问题。

*   **数组实现**以空间换时间，通过简单的数组索引提供了极快的伙伴定位和状态更新能力，非常适合 `MAX_ORDER` 不会太大且内存状态变化频繁的场景。
*   **链表实现**则更加节省空间，仅为空闲块维护元数据，灵活性更高，是现代操作系统中（如 Linux 内核）伙伴系统更常见的实现方式。

选择哪种实现取决于具体的系统约束，如可用内存、对性能的要求以及对代码复杂度的容忍度。
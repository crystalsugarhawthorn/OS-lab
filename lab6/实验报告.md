# 进程调度

小组成员：
- 2310648 高景珩
- 2313892 章昊

---

## 实验目的

- 理解操作系统的调度管理机制
- 熟悉 Round Robin (RR) 调度算法
- 了解并实现 Stride Scheduling 调度算法
- 了解多级反馈队列 (MLFQ) 调度算法

---

## 实验内容

### 练习0：填写已有实验

本实验依赖实验2/3/4/5。我们已经将实验2/3/4/5的代码填入本实验中代码中有“LAB2”/“LAB3”/“LAB4”“LAB5”的注释相应部分，并确保编译通过。

在`trap.c`文件中，我们修改为如下：

```c
case IRQ_S_TIMER:
        clock_set_next_event();
        ticks++;
        // if (ticks == TICK_NUM) {
        //     print_ticks();
        //     print_num++;
        //     ticks = 0;
        //     assert(current != NULL);
        //     current->need_resched = 1;// 让当前进程在时钟中断后重新调度
        // }

        // if (print_num == 10) {
        //     sbi_shutdown();
        // }

        // lab6: YOUR CODE  (update LAB3 steps)
        //  在时钟中断时调用调度器的 sched_class_proc_tick 函数
        sched_class_proc_tick(current);
```

**说明**：我们注释掉了 Lab3 中用于打印 ticks 和自动关机的代码。这是因为 Lab6 的重点是验证调度器的正确性，系统需要持续运行来执行各种测试用例，而不是在固定时间后自动关机。此外，过多的 `100ticks` 输出会干扰 `make grade` 的结果判定和我们在 QEMU 中的观察。现在的核心逻辑是调用 `sched_class_proc_tick` 来驱动调度器的时间片管理。

### 练习1：理解调度器框架的实现（不需要编码）

#### 1. 调度器框架分析

**sched_class 结构体分析**

`sched_class` 结构体定义了一组函数指针，构成了调度算法的统一接口。这种设计模式类似于面向对象编程中的“接口”或“虚函数表”，使得内核的调度器框架可以与具体的调度算法实现解耦。

```c
struct sched_class {
    const char *name;
    void (*init)(struct run_queue *rq);
    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
    struct proc_struct *(*pick_next)(struct run_queue *rq);
    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
};
```

- `init`: 初始化运行队列。
- `enqueue`: 将进程加入运行队列。
- `dequeue`: 将进程从运行队列移除。
- `pick_next`: 选择下一个要执行的进程。
- `proc_tick`: 处理时钟中断，更新进程的时间片等信息。

使用函数指针的原因是允许在运行时动态替换调度算法（例如从 RR 切换到 Stride），而无需修改内核的核心调度逻辑（如 `schedule` 函数）。

**run_queue 结构体分析**

Lab5 中并没有显式的 `run_queue` 结构体，而是直接使用全局的 `proc_list` 进行遍历调度。Lab6 引入了 `run_queue` 来管理处于 `PROC_RUNNABLE` 状态的进程。

```c
struct run_queue {
    list_entry_t run_list;
    unsigned int proc_num;
    int max_time_slice;
    // For LAB6 ONLY
    skew_heap_entry_t *lab6_run_pool;
};
```

- `run_list`: 用于 Round Robin 调度算法的链表结构，按 FIFO 顺序组织进程。
- `lab6_run_pool`: 用于 Stride 调度算法的斜堆（Skew Heap）结构，作为优先队列使用，以便快速取出 stride 最小的进程。

Lab6 的 `run_queue` 需要支持两种数据结构是因为不同的调度算法对就绪队列的组织方式有不同的要求（RR 需要链表，Stride 需要优先队列）。

**调度器框架函数分析**

- `sched_init()`: 初始化 `timer_list`，设置默认的调度算法（`default_sched_class`），并调用具体算法的 `init` 函数初始化运行队列。
- `wakeup_proc()`: 当进程状态变为 `PROC_RUNNABLE` 时，调用 `sched_class_enqueue` 将其加入运行队列。这与 Lab5 直接修改状态不同，Lab6 需要通过调度类接口维护就绪队列。
- `schedule()`: 核心调度函数。它不再像 Lab5 那样直接遍历链表，而是：
    1. 清除当前进程的 `need_resched` 标志。
    2. 如果当前进程仍然处于 `PROC_RUNNABLE` 状态，调用 `sched_class_enqueue` 将其放回运行队列（因为它可能只是时间片用完，而非阻塞）。
    3. 调用 `sched_class_pick_next` 选择下一个进程。
    4. 如果选出了新进程，调用 `sched_class_dequeue` 将其从队列中移除（注意：这里的 dequeue 语义是从“就绪队列”拿出，准备运行，具体实现取决于算法，RR 中通常意味着它正在运行，不在就绪链表中；或者有些实现是运行的进程依然在链表中，这里 ucore 的实现是 pick_next 只是看，不移除，但随后的逻辑可能需要调整，具体看代码实现。在 ucore 的 RR 实现中，`pick_next` 只是返回第一个元素，`dequeue` 是真的移除。但在 `schedule` 函数中，`next` 被 `dequeue` 出来运行）。
    5. 执行上下文切换 `proc_run`。

#### 2. 调度器框架的使用流程

**调度类的初始化流程**

1. 内核启动，执行 `kern_init`。
2. `kern_init` 调用 `sched_init`。
3. `sched_init` 将全局指针 `sched_class` 指向 `default_sched_class` (即 RR 调度器)。
4. 调用 `sched_class->init(rq)`，即 `RR_init`，初始化运行队列的链表和计数器。

**进程调度流程**

1. **触发**: 时钟中断发生，跳转到 `trap_dispatch` -> `run_timer_list` -> `sched_class_proc_tick`。
2. **Tick 处理**: `RR_proc_tick` 减少当前进程 `time_slice`。若减为 0，设置 `current->need_resched = 1`。
3. **调度请求**: 中断返回前或系统调用结束时，检查 `need_resched` 标志。若为 1，调用 `schedule()`。
4. **执行调度**:
    - `schedule()` 调用 `sched_class_enqueue(current)` 把当前进程放回队尾（如果它还 Runnable）。
    - 调用 `sched_class_pick_next(rq)` 从队头选出下一个进程。
    - 调用 `sched_class_dequeue(next)` 把选中的进程从就绪队列移除。
    - 调用 `proc_run(next)` 切换上下文。

`need_resched` 标志位的作用是推迟调度的执行。在中断处理程序中，我们不直接进行耗时的上下文切换，而是标记需要调度，待中断处理完成、即将返回用户态或内核态的合适时机（如 `trap` 函数末尾）再统一处理。

**调度算法的切换机制**

如果要添加一个新的调度算法（如 Stride）：
1. 实现一个新的 `sched_class` 实例（如 `stride_sched_class`），填充对应的函数指针。
2. 在 `sched_init` 中，将 `sched_class` 指针指向新的调度类实例。

这种设计使得切换算法非常容易，只需修改初始化时的一行指针赋值代码，无需改动核心调度逻辑。

### 练习2：完成 Round Robin 调度算法（需要编码）

#### 1. Lab5 与 Lab6 的区别比较

以 `schedule` 函数为例：

**Lab5 的实现：**
```c
void schedule(void) {
    // ...
    // 直接遍历 proc_list 寻找 PROC_RUNNABLE 的进程
    do {
        if ((le = list_next(le)) != &proc_list) {
            next = le2proc(le, list_link);
            if (next->state == PROC_RUNNABLE) break;
        }
    } while (le != last);
    // ...
    proc_run(next);
}
```

**Lab6 的实现：**
```c
void schedule(void) {
    // ...
    // 使用 sched_class 接口
    if (current->state == PROC_RUNNABLE) {
        sched_class_enqueue(current); // 将当前进程放回就绪队列
    }
    if ((next = sched_class_pick_next()) != NULL) {
        sched_class_dequeue(next); // 从就绪队列取出下一个进程
    }
    // ...
    proc_run(next);
}
```

**原因与影响：**
Lab5 的实现将调度策略（简单的轮询）硬编码在 `schedule` 函数中，缺乏灵活性，且随着进程数量增加，遍历链表的效率较低。Lab6 通过 `sched_class` 抽象，将“怎么选进程”的逻辑剥离出去，支持了 O(1) 或 O(log N) 的复杂调度算法，且支持动态切换。如果不做这个改动，无法支持后续的 Stride 或其他高级调度算法。

#### 2. Round Robin 实现思路

我们实现了 `kern/schedule/default_sched.c` 中的接口：

- **RR_init**: 负责初始化运行队列结构体。初始化 `run_list` 为空链表，`proc_num` 置 0。
- **RR_enqueue**: 负责将进程加入就绪队列。
    - 使用 `list_add_before` 将进程加入 `run_list` 的尾部（即头结点的 prev 方向）。
    - 如果进程的时间片 `time_slice` 为 0 或超过最大值，将其重置为 `max_time_slice`。
    - 更新 `proc->rq` 和 `rq->proc_num`。
- **RR_dequeue**: 负责将进程从就绪队列中移除。
    - 使用 `list_del_init` 将进程从链表中移除。
    - 减少 `rq->proc_num`。
- **RR_pick_next**: 负责选择下一个将要执行的进程。
    - 查看 `run_list` 的第一个元素（`list_next`）。
    - 如果链表不为空，返回对应的进程；否则返回 NULL。
    - 这里选择链表头作为下一个运行的进程，配合 `enqueue` 的尾部插入，实现了 FIFO 逻辑。
- **RR_proc_tick**: 负责在时钟中断时更新进程的时间片。
    - 递减 `proc->time_slice`。
    - 如果减为 0，说明时间片耗尽，设置 `proc->need_resched = 1`，触发调度。

#### 3. 实验结果

执行结果如下（截取）：

```text
heng@LAPTOP-J22B2DMJ:/mnt/d/nankai/OS/OS-lab/lab6$ make grade
priority:                (3.2s)
  -check result:                             OK
  -check output:                             OK
Total Score: 50/50
heng@LAPTOP-J22B2DMJ:/mnt/d/nankai/OS/OS-lab/lab6$ make qemu

OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
(THU.CST) os is loading ...

Special kernel symbols:
  entry  0xc020004a (virtual)
  etext  0xc020585a (virtual)
  edata  0xc02c2710 (virtual)
  end    0xc02c6bf0 (virtual)
Kernel executable memory footprint: 795KB
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
memory management: default_pmm_manager
physcial memory map:
  memory: 0x08000000, [0x80000000, 0x87ffffff].
vapaofset is 18446744070488326144
check_alloc_page() succeeded!
check_pgdir() succeeded!
check_boot_pgdir() succeeded!
use SLOB allocator
kmalloc_init() succeeded!
check_vma_struct() succeeded!
check_vmm() succeeded.
sched class: RR_scheduler
++ setup timer interrupts
kernel_execve: pid = 2, name = "priority".
set priority to 6
main: fork ok,now need to wait pids.
set priority to 1
set priority to 2
set priority to 3
set priority to 4
set priority to 5
child pid 3, acc 1064000, time 2010
child pid 4, acc 1048000, time 2010
child pid 5, acc 1060000, time 2010
child pid 6, acc 1056000, time 2010
child pid 7, acc 1048000, time 2010
main: pid 0, acc 1064000, time 2010
main: pid 4, acc 1048000, time 2010
main: pid 5, acc 1060000, time 2010
main: pid 6, acc 1056000, time 2010
main: pid 7, acc 1048000, time 2010
main: wait pids over
sched result: 1 1 1 1 1
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:545:
    initproc exit.
```


#### 4. 算法分析与扩展

**优缺点：**
- **优点**：实现简单，公平性好（每个进程都有机会执行），响应时间较短（对于交互式任务）。
- **缺点**：平均周转时间较长；如果时间片设置不当，可能导致过多的上下文切换开销（时间片太短）或退化为 FCFS（时间片太长）。

**时间片优化：**
时间片的大小直接影响系统性能。太小会导致频繁的上下文切换，浪费 CPU 时间；太大会导致交互响应变差。通常需要根据系统的负载类型（CPU 密集型 vs I/O 密集型）和硬件切换开销来权衡。

**need_resched 的作用：**
在 `RR_proc_tick` 中设置 `need_resched` 是为了通知内核“当前进程的时间片已用完，请尽快调度”。由于 `proc_tick` 是在中断上下文中执行的，不能直接进行进程切换，所以通过标志位的方式，让内核在适当的时机（如中断返回前）执行 `schedule`。

**扩展思考：优先级 RR 与多核**
- **优先级 RR**: 可以维护多个优先级的队列（如 `run_list_prio[MAX_PRIO]`）。`pick_next` 时先扫描高优先级队列，若为空再扫描低优先级。或者在同一个队列中，`enqueue` 时根据优先级插入到合适位置。
- **多核调度**: 当前实现是单核的全局运行队列。支持多核需要：
    1. 每个 CPU 拥有独立的 `run_queue`。
    2. 引入锁机制保护队列操作。
    3. 实现负载均衡（Load Balance），在 CPU 间迁移进程。

### 扩展练习 Challenge 1: 实现 Stride Scheduling 调度算法（需要编码）

#### 1. 多级反馈队列 (MLFQ) 设计概要

多级反馈队列旨在同时满足短作业优先（低周转时间）和交互式任务优先（低响应时间）的需求，同时避免饥饿。

**设计思路：**
1.  **多级队列**：设置多个就绪队列，优先级从高到低（Q1, Q2, ..., Qn）。
2.  **优先级分配**：新进程进入最高优先级队列 Q1。
3.  **时间片策略**：高优先级队列时间片短，低优先级队列时间片长。
4.  **降级机制**：如果进程在当前队列的时间片内未完成（CPU 密集型），则移入下一级低优先级队列。
5.  **升级机制（防饥饿）**：如果进程在低优先级队列等待过久，提升其优先级（Priority Boost）。

#### 2. Stride 算法原理与证明

Stride 调度算法通过控制进程的 `pass` 值来决定调度顺序。
- 每个进程有一个 `stride` (步长)，`stride = BIG_STRIDE / priority`。
- 每个进程有一个 `pass` (进度)，初始为 0。
- 每次调度选择 `pass` 最小的进程 P。
- 调度后，更新 `P.pass += P.stride`。

**证明（直观说明）：**
假设进程 $P_i$ 的优先级为 $W_i$，步长 $S_i = C / W_i$（$C$ 为常数）。
在一段时间 $T$ 内，进程 $P_i$ 被调度的次数为 $N_i$。
由于调度器总是维持各个进程的 `pass` 值大致相等（因为总是选最小的往前走），所以有：
$N_i \times S_i \approx N_j \times S_j$ (对于任意进程 $i, j$)
即 $N_i \times (C / W_i) \approx N_j \times (C / W_j)$
$\Rightarrow N_i / W_i \approx N_j / W_j$
$\Rightarrow N_i \propto W_i$
即进程获得的调度次数（时间片数）与其优先级成正比。

#### 3. Stride 实现过程

我们实现了 `kern/schedule/default_sched_stride.c`：

- **BIG_STRIDE**: 定义为 `(1 << 30)`，也就是 `0x7FFFFFFF` 的一半左右，防止溢出但保持足够精度。
- **stride_init**: 初始化 `lab6_run_pool` 为 NULL（空斜堆），`run_list` 初始化（虽然主要用堆，但保持一致性）。
- **stride_enqueue**:
    - 使用 `skew_heap_insert` 将进程加入优先队列 `lab6_run_pool`。
    - 比较函数 `proc_stride_comp_f` 比较进程的 `lab6_stride` (注意：代码中变量名可能是 `lab6_stride` 对应 pass 概念，或者 ucore 实现中直接用 `stride` 变量累加，这里我们遵循 ucore 的命名习惯，`lab6_stride` 实际上存储的是当前的 pass 值，而步长是计算出来的)。
    - 更新 `time_slice` 和 `proc_num`。
- **stride_dequeue**:
    - 使用 `skew_heap_remove` 将进程从堆中移除。
- **stride_pick_next**:
    - 检查 `lab6_run_pool` 是否为空。
    - 获取堆顶进程（`pass` 最小）。
    - **关键步骤**：更新该进程的 `pass` 值：`p->lab6_stride += BIG_STRIDE / p->lab6_priority`。
    - 返回该进程。
- **stride_proc_tick**: 与 RR 一致，处理时间片递减。

通过 `make grade` 测试，Stride 调度器同样通过了所有测试点，并且在优先级测试中表现出了预期的比例分配特性。

#### 4. Stride 与 RR 算法的切换

在 `kern/schedule/sched.c` 中的 `sched_init()` 函数里，控制点位于：

```c
void sched_init(void)
{
    list_init(&timer_list);

    sched_class = &default_sched_class;  // <-- 在这里切换算法

    rq = &__rq;
    rq->max_time_slice = MAX_TIME_SLICE;
    sched_class->init(rq);

    cprintf("sched class: %s\n", sched_class->name);
}
```

要切换到 Stride 调度算法，只需将这一行改为：
```c
sched_class = &stride_sched_class;
```

这正体现了调度器框架的设计优雅性：通过改变一个指针的指向，就可以实现从 RR 到 Stride 的完整算法切换。具体地：
- `default_sched_class` 是在 `kern/schedule/default_sched.c` 中定义的 RR 调度器实例。
- `stride_sched_class` 是在 `kern/schedule/default_sched_stride.c` 中定义的 Stride 调度器实例。

两者都在 `kern/schedule/default_sched.h` 中通过 `extern` 声明导出：
```c
extern struct sched_class default_sched_class;
extern struct sched_class stride_sched_class;
```

这样的设计完全遵循了"机制与策略分离"的原则，核心调度逻辑（`schedule()`, `wakeup_proc()` 等）完全不知道具体使用的是哪种算法，它们只通过 `sched_class` 函数指针表与算法交互。

### 扩展练习 Challenge 2：实现多种调度算法并进行性能对比

#### 1. 实现的调度算法

我们在 uCore 上实现了以下调度算法：

##### (1) FIFO (First In First Out) - 先进先出调度

**算法原理**：按照进程进入就绪队列的顺序进行调度，最早到达的进程最先执行。

**实现要点** ([kern/schedule/fifo_sched.c](kern/schedule/fifo_sched.c))：
- `FIFO_enqueue`: 将进程添加到队列尾部
- `FIFO_pick_next`: 总是选择队首进程（最早进入的）
- 给予较长的时间片（`max_time_slice * 100`），尽量模拟非抢占特性

**特点**：
- 实现简单，公平
- 可能导致"护航效应"（Convoy Effect）：短作业被长作业阻塞
- 平均周转时间较长
- 适用场景：批处理系统，对响应时间要求不高的场景

##### (2) SJF (Shortest Job First) - 短作业优先调度

**算法原理**：选择预估执行时间最短的进程优先执行，理论上可以最小化平均等待时间。

**实现要点** ([kern/schedule/sjf_sched.c](kern/schedule/sjf_sched.c))：
- 使用 `proc->lab6_priority` 作为预估的执行时间（值越小表示时间越短）
- `SJF_enqueue`: 按照优先级（执行时间）插入到有序位置
- `SJF_pick_next`: 由于已排序，直接返回队首进程

**特点**：
- 理论上最优（最小化平均等待时间）
- 需要预知进程执行时间（实际中很难做到）
- 可能导致长作业饥饿（Starvation）
- 适用场景：作业执行时间可预测的批处理系统

##### (3) RR (Round Robin) - 时间片轮转

已在练习2中实现，特点：
- 公平，响应时间短
- 上下文切换开销较大
- 适用场景：分时系统，交互式应用

##### (4) Stride Scheduling - 步长调度

已在 Challenge 1 中实现，特点：
- 支持优先级，比例分配CPU时间
- 避免饥饿
- 适用场景：需要保证服务质量（QoS）的系统

##### (5) HRRN (Highest Response Ratio Next) - 最高响应比优先调度

**算法原理**：综合考虑等待时间和服务时间，选择响应比最高的进程执行。

响应比计算公式：$RR = \frac{等待时间 + 服务时间}{服务时间} = 1 + \frac{等待时间}{服务时间}$

**实现要点** ([kern/schedule/hrrn_sched.c](kern/schedule/hrrn_sched.c))：
- 使用 `proc->lab6_priority` 作为预估服务时间
- 使用 `proc->lab6_stride` 记录进程进入就绪队列的时间
- `HRRN_pick_next`: 遍历所有进程，计算响应比，选择最大的
- 为避免浮点运算，实际计算 $RR \times 服务时间 = 服务时间 + 等待时间$

**特点**：
- 综合了 FCFS 和 SJF 的优点
- 短作业优先，但避免长作业饥饿（等待越久，响应比越高）
- 兼顾公平性和效率
- 每次调度需要遍历所有进程，开销较大（O(n)）
- 适用场景：批处理系统，需要兼顾短作业和长作业的场景


#### 2. 性能测试与定量分析

##### 测试程序: [user/sched_test.c](user/sched_test.c)
创建5个不同工作负载的进程（短作业、中等作业、长作业），统计：
- **周转时间** (Turnaround Time)：从进程创建到完成的总时间
- **执行时间** (Execution Time)：实际CPU执行时间
- **等待时间** (Waiting Time)：周转时间 - 执行时间

##### 测试场景设计

| 进程ID | 工作负载 | 优先级 (Stride/SJF) | 说明 |
|--------|----------|---------------------|------|
| 0 | 轻量 (100K) | 5 | 短作业，低优先级 |
| 1 | 重量 (1M) | 1 | 长作业，高优先级 |
| 2 | 中等 (500K) | 3 | 中等作业 |
| 3 | 轻量 (100K) | 4 | 短作业 |
| 4 | 重量 (1M) | 2 | 长作业 |

#### 3. 算法适用范围总结

| 算法 | 最适合场景 | 不适合场景 | 典型应用 |
|------|----------|-----------|---------|
| **FIFO** | 批处理系统，作业执行时间相近 | 交互式系统，作业时间差异大 | 打印队列 |
| **SJF** | 批处理，已知作业时间 | 交互式，长作业密集 | 作业调度 |
| **RR** | 分时系统，交互式应用 | CPU密集型批处理 | 通用操作系统 |
| **Stride** | 需要QoS保证的系统 | 简单场景（过于复杂） | 多媒体服务器 |

#### 4.5种调度算法，我们深刻理解了：

1. **没有完美的调度算法**：每种算法都有其适用场景和局限性
   - FIFO 简单但有护航效应
   - SJF 理论最优但可能饥饿
   - RR 公平但切换开销大
   - HRRN 兼顾公平与效率，但计算复杂

2. **公平性与效率的权衡**：
   - FIFO 公平但低效
   - SJF 高效但不公平
   - HRRN 在两者间找到平衡点

3. **理论与实践的差距**：
   - SJF/HRRN 理论上需要预知执行时间，实际很难做到
   - 只能通过历史数据或用户提供的估计值

4. **算法复杂度的影响**：
   - FIFO/RR: O(1) - 性能好，适合实时系统
   - SJF/HRRN: O(n) - 每次调度都要遍历，进程多时开销大
   - Stride: O(log n) - 使用堆结构，性能居中

5. **框架设计的重要性**：良好的抽象使得算法切换变得简单，我们只需实现 `sched_class` 接口即可集成新算法效但不公平

---

## 知识点总结

### 1. 进程调度算法
- **实验点**：RR 算法、Stride 算法的实现。
- **原理点**：FCFS, SJF, RR, MLFQ, Fair Share Scheduling。
- **理解**：实验中的 RR 是最基础的分时调度，体现了公平性；Stride 则是比例共享调度的典型代表，体现了优先级的概念。原理中的 MLFQ 更侧重于动态调整，适应不同类型的负载。

### 2. 调度时机与上下文切换
- **实验点**：`schedule()` 函数的调用、`need_resched` 标志、`proc_run`。
- **原理点**：抢占式 vs 非抢占式调度、用户态/内核态切换、寄存器保存与恢复。
- **理解**：实验清晰地展示了“被动抢占”（时间片耗尽 -> 中断 -> 标记 -> 调度）的流程。上下文切换是调度的核心机制，涉及硬件状态的保存。

### 3. 调度器框架 (Policy vs Mechanism)
- **实验点**：`sched_class` 接口。
- **原理点**：机制与策略分离。
- **理解**：`schedule()` 函数是机制，负责“切换”这个动作；`sched_class` 是策略，负责“决定切换给谁”。这种分离使得操作系统具有极好的扩展性。

### 4. 实验中未涉及的重要原理
- **多核调度 (SMP Scheduling)**：实验仅涉及单核，未处理多核间的负载均衡、亲和性（Affinity）等问题。
- **实时调度 (Real-time Scheduling)**：如 RMS, EDF 等硬实时算法，实验主要关注通用分时系统。
- **CFS (Completely Fair Scheduler)**：Linux 当前的默认调度器，虽然思想与 Stride 类似（基于虚拟运行时间 vruntime），但实现细节（红黑树、权重计算）更为复杂和精细。

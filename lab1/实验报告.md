# 最小可执行内核
---
## 实验目的

在本章中，我将主要阐述最小可执行内核的构建方法及其详细的启动流程。本次实验的内核项目运行于Qemu模拟器之上，该模拟器为我们提供了一个64位RISC-V计算机的模拟环境。

为确保内核能与Qemu模拟器正确对接，我首先对Qemu的启动流程、程序的内存布局以及交叉编译过程（特别是链接环节）的相关知识进行了梳理。

本章的具体内容涵盖了以下几个核心环节：
- 内存布局描述： 我使用了链接脚本（Linker Script）来精确描述内核的内存布局。
- 编译与镜像生成： 我通过交叉编译工具链生成了RISC-V平台的可执行文件，并在此基础上构建了最终的内核镜像。
- 引导与模拟： 我利用OpenSBI作为引导加载程序（Bootloader），在Qemu环境中成功加载并模拟运行了内核镜像。
- 基础调试： 我调用了OpenSBI提供的底层服务，实现了在屏幕上的格式化字符串打印，以此作为后续开发的基础调试手段。
  
---

## 实验内容

### 练习1：理解内核启动中的程序入口操作

*阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？*

根据我查阅的资料，操作系统的启动是一个从硬件加电到内核完全接管计算机并准备好运行用户程序的精密过程。这个过程环环相扣，可以概括为以下几个核心阶段：BIOS/UEFI启动、Bootloader加载内核、内核初始化和启动、内核运行用户程序。

1. BIOS/UEFI 固件启动
   - 计算机加电后，主板上的固件（BIOS 或 UEFI）首先执行。
   - 进行开机自检 (POST)，检查 CPU、内存、硬盘等关键硬件是否正常工作。
   - 根据预设的启动顺序，查找并准备加载引导设备（如硬盘）。

2. 引导加载程序 (Bootloader)
   - BIOS/UEFI 将控制权交给存储在引导设备上的 Bootloader（例如 GRUB）。
   - Bootloader 的核心任务是将操作系统的内核映像（Kernel Image）从硬盘加载到内存中。
  
3. 内核加载与初始化前期
    - 内核映像被加载到内存后，控制权正式移交给内核。
    - 内核的执行从一个预定义的、用汇编语言编写的入口点开始，即我们代码中的 entry。
    - 在这个极早期的阶段，需要完成最基础的硬件设置，其中最关键的一步就是建立一个有效的栈空间，为即将运行的 C 语言函数做准备。

4. 内核初始化
    - 内核开始执行 C 语言代码，进行一系列的初始化操作，包括设置内核数据结构、初始化硬件设备、挂载文件系统等。
    - 最终，内核准备好运行用户程序，并开始执行用户程序的入口点。

5. 用户程序运行
    - 内核通过系统调用或进程管理机制，将用户程序加载到内存中并开始执行。
    - 用户程序可以进一步调用操作系统提供的各种服务，如文件操作、网络通信等。

在我们的学习环境中，`kern/init/entry.S` 文件扮演了上述流程中第 3 阶段的角色，是内核的“第一行代码”。它负责从硬件的原始状态过渡到 C 语言函数可以运行的环境。

对entry.S进行分析，可以得到以下结论：

```
// 包含 C 语言的头文件。汇编器在处理前，会由 C 预处理器 (cpp) 先处理这些指令。
// 引入 MMU (Memory Management Unit) 相关的宏定义，例如 PGSHIFT (页大小的对数，通常为 12)。
#include <mmu.h>

// 引入内存布局相关的宏定义，例如 KSTACKSIZE (内核栈的大小)。
#include <memlayout.h>

    // 声明一个代码段 (section)。
    // .text: 这是标准的段名，用于存放可执行指令。
    // "ax": 是段的属性标志。
    //   'a' -> allocatable (可分配)，表示加载时需要为这个段分配内存。
    //   'x' -> executable (可执行)，表示这个段中的内容是 CPU 指令。
    // %progbits: 表示这个段包含程序数据。
    .section .text,"ax",%progbits

    // .globl (同 .global) 是一个汇编指令，用于将一个符号声明为全局的。
    // 这使得链接器 (linker) 可以从其他文件中引用 kern_entry 这个符号。
    // 这里是将 kern_entry 声明为内核的全局入口点。
    .globl kern_entry

// 定义一个标签 (label) 'kern_entry'。这是引导加载程序 (Bootloader) 跳转到内核时执行的第一条指令的地址。
kern_entry:

    // 'la' 是 "Load Address" 的伪指令。
    // 'sp' 是栈指针寄存器 (Stack Pointer)。
    // 'bootstacktop' 是下面数据段中定义的一个标签，代表启动栈的最高地址。
    // 整条指令的用途：将启动栈的栈顶地址加载到 sp 寄存器中，从而初始化内核的第一个栈。
    // 这是为后续调用 C 函数 (kern_init) 做准备的关键步骤。
    la sp, bootstacktop

    // 'tail' 是一条尾调用 (Tail Call) 伪指令，它实际上是一个无条件跳转指令 (jump)。
    // 'kern_init' 是一个在其他 C 文件中定义的内核初始化函数。
    // 整条指令的用途：跳转到 kern_init 函数开始执行，并且不会保存返回地址。
    // 因为内核初始化是单向过程，永远不会返回到 kern_entry，所以使用 tail 更高效。
    tail kern_init

// 声明一个数据段 (.data)，用于存放已初始化的全局变量和静态变量。
.section .data

    // .align 是对齐指令。它确保下面的数据地址是某个值的倍数。
    // PGSHIFT 通常是 12，所以 2^12 = 4096 字节（一个内存页）。
    // 这行代码确保 bootstack 的起始地址按页大小对齐，这对于内存管理非常重要。
    # .align 2^12
    .align PGSHIFT

    // 将 'bootstack' 符号声明为全局的，使其在链接时对其他文件可见。
    .global bootstack

// 定义一个标签 'bootstack'，它代表了内核启动栈的起始地址（最低地址）。
bootstack:

    // .space 指令用于在当前位置保留一块指定大小（字节）的连续内存空间，并用 0 填充。
    // KSTACKSIZE 是一个宏，定义了内核栈的大小（例如 8192 字节, 即 8KB）。
    // 这行代码为内核启动栈预留了实际的内存空间。
    .space KSTACKSIZE

    // 将 'bootstacktop' 符号声明为全局的。
    .global bootstacktop

// 定义一个标签 'bootstacktop'。
// 因为这个标签紧跟在 .space KSTACKSIZE 之后，所以它代表了 bootstack 内存区域的结束地址（最高地址）。
// 由于栈是向下生长的（从高地址向低地址使用），这个地址正是栈顶指针 sp 需要被初始化的值。
bootstacktop:
```

综上，在这段汇编代码中，la sp, bootstacktop 的作用是将内核启动时的栈顶地址加载到栈指针寄存器 sp 中。具体来说，bootstack 在数据段中开辟了一段空间作为内核启动栈（大小为 KSTACKSIZE），而 bootstacktop 则标记了这段栈空间的顶部地址。由于栈在 RISC-V 架构中是向下生长的，因此初始化时必须让 sp 指向栈顶位置，以便后续的函数调用和局部变量能够正确使用栈空间。这一步的目的，就是为内核初始化过程建立一个安全、独立的运行时栈环境。

接着的 tail kern_init 指令是一种伪指令，它的效果相当于一个“无返回”的跳转。它会直接跳转到 kern_init 函数的入口，并用新的指令地址覆盖当前调用点，而不会在栈中留下返回地址。换句话说，这是一种“尾调用优化”：执行 kern_init 时，程序不再需要返回到 kern_entry，而是将控制权完全交给 kern_init。这样做的目的，是将内核真正的初始化逻辑切换为主执行流程，避免在栈上留下无用的调用信息，同时保证内核启动流程简洁高效。

### 练习2：理解内核启动中的链接脚本
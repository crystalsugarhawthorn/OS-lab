# 进程管理

小组成员：
- 2310648 高景珩
- 2313892 章昊

---

## 实验目的

- 了解虚拟内存管理的基本结构，掌握虚拟内存的组织与管理方式
- 了解内核线程创建/执行的管理过程
- 了解内核线程的切换和基本调度过程

---

## 实验内容

### 练习1：分配并初始化一个进程控制块（需要编码）

*alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。*
*请说明proc_struct中struct context context和struct trapframe \*tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来*

在 `alloc_proc` 中，我调用 `kmalloc` 生成新的 `proc_struct` 后，依次把字段写成干净的初值：`state` 取 `PROC_UNINIT`、`pid` 为 `-1`；`runs`、`kstack`、`need_resched`、`flags` 等计数/标志清零；`parent`、`mm`、`tf` 赋值为 `NULL`，`pgdir` 指向 `boot_pgdir_pa`。再通过 `memset` 清空 `context` 与 `name` 数组，并对 `list_link`、`hash_link` 调用 `list_init`。这样能让 `proc_init` 的自检通过，内核会打印 `alloc_proc() correct!`。

`struct context context` 与 `struct trapframe *tf` 负责不同层面的现场保存：

- `context` 保存了调度器进行内核线程切换时必须保存/恢复的寄存器（`ra`、`sp`、`s0~s11`）。`switch_to` 会把当前线程的寄存器写入 `context`，再从目标线程的 `context` 恢复，实现内核态的上下文切换。
- `tf` 指向内核栈顶部的中断帧。进程因为中断、异常或系统调用进入内核时，汇编入口（如 `trapentry.S`）把所有通用寄存器以及 `status`、`epc` 等现场压入栈中形成 `trapframe`，内核通过 `tf` 访问/修改用户态寄存器并在返回时恢复现场。

总的来说，`context` 保障“进程之间”的切换过程，`tf` 保障“一次 trap 内”从用户态到内核态再回去的完整状态记录。

### 练习2：为新创建的内核线程分配资源（需要编码）

*创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们实际需要"fork"的东西就是stack和trapframe。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：*
*调用alloc_proc，首先获得一块用户信息块。为进程分配一个内核栈。复制原进程的内存管理信息到新进程（但内核线程不必做此事）。复制原进程上下文到新进程。将新进程添加到进程列表。唤醒新进程。返回新进程号。*
*请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。*

按照指导我们在 `do_fork` 中补全了完整的资源分配路径：首先调用 `alloc_proc` 拿到一块新的 `proc_struct`，并立即把 `parent` 指向当前进程，方便之后回收；接着通过 `setup_kstack` 向物理内存申请 `KSTACKPAGE` 页作为子进程的内核栈，失败时释放 `proc_struct` 并直接返回错误；随后执行 `copy_mm`，对于本实验的纯内核线程该函数实际什么都不做；然后由 `copy_thread` 把父线程传入的 `trapframe` 复制到新内核栈顶部，同时设置 `context.ra = forkret`、`context.sp = proc->tf`，保证后续调度时能顺利跳到 `forkret→forkrets` 继续执行。资源准备好后，调用 `get_pid` 分配 PID，分别插入 `hash_proc` 和 `list_add(&proc_list, …)`，更新 `nr_process` 计数，最后用 `wakeup_proc` 把状态切成 `PROC_RUNNABLE` 并返回新的 PID。出错路径下我们依次释放内核栈 (`put_kstack`) 与 `proc_struct`，防止内存泄漏。

`get_pid` 的核心逻辑在 `proc.c` 第 74 行起：它维护 `last_pid`、`next_safe` 两个静态变量，对 `proc_list` 做全表扫描。如果当前 `last_pid` 已被占用，就递增并（必要时）环回为 `1` 重新扫描；扫描时同时记录大于 `last_pid` 的最小 PID 作为新的 `next_safe`，从而避免重复。因为每次发号前都检查现有进程列表，所以只要 `proc_list` 中没有重复 PID，`get_pid` 就能确保给新 fork 的线程发放唯一 ID。实验中 `proc_init` 也通过 `assert(initproc->pid == 1)` 验证了这一点。

### 练习3：编写proc_run 函数（需要编码）

*proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：*
*检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换；禁用中断；切换当前进程为要运行的进程；切换页表，以便使用新进程的地址空间；实现上下文切换；允许中断*
*在本实验的执行过程中，创建且运行了几个内核线程？*

`proc_run` 的实现紧跟这一流程：若目标与 `current` 相同直接返回；否则用 `local_intr_save` 关中断，保存旧的 `current` 为 `prev`，再把全局 `current` 指针切换到目标进程。随后通过 `lsatp(proc->pgdir)` 切换页表（虽然内核线程共享页表，但框架上必须在此时更新 SATP），最后调用 `switch_to(&prev->context, &proc->context)` 触发上下文切换，待 `switch_to` 结束后用 `local_intr_restore` 恢复中断，使得 CPU 继续在新线程上下文中运行。

从 `proc_init` 的启动路径可以看出，本实验创建并运行了两个内核线程：自举时 `idleproc` 自身（PID=0）先被设置为 `PROC_RUNNABLE`，随后调用 `kernel_thread(init_main, …)` 通过 `do_fork` 创建 `initproc`（PID=1）。调度器在 `cpu_idle` 循环里，在 `current->need_resched` 置位后会在这两个线程之间切换运行，因此实验执行过程中实际参与调度的内核线程数量为 2 个。

### 扩展练习 Challenge

1. *说明语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断的？*

这两条语句是一对封装好的宏/内联函数，内部针对 S 态中断允许位做保存与恢复：`local_intr_save(flag)` 首先读取当前 `sstatus` 寄存器，把 SIE 位（Supervisor Interrupt Enable）保存在 `flag` 中，然后通过 `clear_csr(sstatus, SSTATUS_SIE)` 清掉 SIE 位，达到“关闭中断”的效果；`local_intr_restore(flag)` 再根据保存的 `flag` 判定之前是否已开启中断，若原先为 1 就执行 `set_csr(sstatus, SSTATUS_SIE)`。这样可以在临界区内避免被打断，同时保证离开临界区后恢复到进入前的中断状态，而不会误将本来关闭的中断强行打开。

2. *深入理解不同分页模式的工作原理（思考题）*
*get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。*
*get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？*

RISC-V 的分页模式（SV32/SV39/SV48）本质都是 n 级多级页表索引：虚拟地址拆成若干层页号（VPN[i]）和页内偏移，按层级逐级索引页表、找到下一级页表的基地址。`get_pte` 中的两段近似循环体，第一次用上层页号（SV39 中是 `VPN[2]`）定位到二级页表（页目录），第二次再用下一层页号（`VPN[1]`）定位真正的页表项。结构几乎完全相同，是因为每一级都执行同样的“取出 PTE→若无效且允许则分配→填入新页表地址→继续索引”流程，只是访问的数组和位段不同；换成 SV48 就会多出一段同构代码。

查找与按需分配写在同一个函数内好处是使用者无需区分“只查找”与“需要保证存在”两种场景——类似 Linux 的 `pte_alloc`/`get_pte`，能在页表缺失时自动补齐，调用点简单。但这也带来副作用：调用者若只想探测映射存在性却意外传入 `create=true`，会无意中分配新页表，增加副作用；并且错误传播路径被耦合在一起。实际内核常见写法是提供两个接口：`get_pte(pgdir, la, false)` 只查找，`pgdir_alloc_page` 等需要时才用 `true` 创建。本实验规模较小，合并在一起能简化代码；若系统更复杂、需要频繁区分“只查表/不分配”的路径，拆分成两个函数更安全可读。

## 知识点总结
- **内核线程生命周期**：掌握了通过 `alloc_proc → do_fork → wakeup_proc` 构造线程的完整链路，理解 PCB 初始状态、内核栈与 trapframe 如何配合支撑线程从诞生到调度运行。
- **上下文切换机制**：区分 `context` 与 `trapframe` 在进程调度与中断返回中的职责，明白 `proc_run`/`switch_to` 如何借助保存的寄存器现场在不同线程间切换。
- **多级页表操作**：复习了 RISC-V SV32/SV39/SV48 的分级索引规律，理解 `get_pte` 在缺页场景下按需分配页表、维护内核虚拟内存映射的流程。
- **中断控制与并发**：通过 `local_intr_save/restore` 框架理解了 S 态中断屏蔽位的管理，以及在访问全局调度结构时必须屏蔽中断、保持原子性的原因。
- **进程标识与调度策略**：分析 `get_pid` 的循环发号逻辑，理解 uCore 采用的简单可抢占调度：`schedule` 线性扫描可运行队列、按需调用 `proc_run`，体现最小化调度器核心的设计理念。


